// tslint:disable
/**
 * document-v1
 * Document API Service  Handles the generation and storage of customer policy and quote documentation. 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * JSON API message.
 * @export
 * @interface ApiMessage
 */
export interface ApiMessage {
    /**
     * HTTP status code.
     * @type {number}
     * @memberof ApiMessage
     */
    status?: number;
    /**
     * HTTP status text.
     * @type {string}
     * @memberof ApiMessage
     */
    error?: string;
    /**
     * Custom message.
     * @type {string}
     * @memberof ApiMessage
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface CreatedTrait
 */
export interface CreatedTrait {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdBy: string;
}
/**
 * Reference to a DatasheetProperty resource.
 * @export
 * @interface DatasheetPropertyKey
 */
export interface DatasheetPropertyKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    datasheetPropertyId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    version: string;
}
/**
 * Policy document resource
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof Document
     */
    documentId: string;
    /**
     * Reference to the owning policy.
     * @type {PolicyKey}
     * @memberof Document
     */
    policy?: PolicyKey;
    /**
     * Reference to the owning quote.
     * @type {QuoteKey}
     * @memberof Document
     */
    quote?: QuoteKey;
    /**
     * The user that owns the document.
     * @type {string}
     * @memberof Document
     */
    userId: string;
    /**
     * 
     * @type {DocumentTypeKey}
     * @memberof Document
     */
    documentType: DocumentTypeKey;
    /**
     * Internal resource idenitfier for the physical file.
     * @type {string}
     * @memberof Document
     */
    uri: string;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Document
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Document
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Document
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Document
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Core document resource data.
 * @export
 * @interface DocumentBody
 */
export interface DocumentBody {
    /**
     * Reference to the owning policy.
     * @type {PolicyKey}
     * @memberof DocumentBody
     */
    policy?: PolicyKey;
    /**
     * Reference to the owning quote.
     * @type {QuoteKey}
     * @memberof DocumentBody
     */
    quote?: QuoteKey;
    /**
     * The user that owns the document.
     * @type {string}
     * @memberof DocumentBody
     */
    userId: string;
    /**
     * 
     * @type {DocumentTypeKey}
     * @memberof DocumentBody
     */
    documentType: DocumentTypeKey;
    /**
     * Internal resource idenitfier for the physical file.
     * @type {string}
     * @memberof DocumentBody
     */
    uri: string;
}
/**
 * Reference to a document resource.
 * @export
 * @interface DocumentKey
 */
export interface DocumentKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DocumentKey
     */
    documentId: string;
}
/**
 * Page of document resources
 * @export
 * @interface DocumentPagedModel
 */
export interface DocumentPagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof DocumentPagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalDocumentListEmbedded}
     * @memberof DocumentPagedModel
     */
    _embedded?: HalDocumentListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof DocumentPagedModel
     */
    page?: object;
}
/**
 * Document request.
 * @export
 * @interface DocumentRequest
 */
export interface DocumentRequest {
    /**
     * Reference to the owning policy. Required if the documentType.dataModel is POLICY.
     * @type {PolicyKey}
     * @memberof DocumentRequest
     */
    policy?: PolicyKey;
    /**
     * Reference to the owning quote. Required if the documentType.dataModel is QUOTE.
     * @type {QuoteKey}
     * @memberof DocumentRequest
     */
    quote?: QuoteKey;
    /**
     * 
     * @type {DocumentTypeKey}
     * @memberof DocumentRequest
     */
    documentType: DocumentTypeKey;
}
/**
 * Type of policy document. Includes a reference to the related template and optionally defines the set of policy attributes/properties that are required in order to generate this document.
 * @export
 * @interface DocumentType
 */
export interface DocumentType {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DocumentType
     */
    documentTypeId: string;
    /**
     * Title or name of the document. Should be unique in the system.
     * @type {string}
     * @memberof DocumentType
     */
    name: string;
    /**
     * Name of the template that is used to generate the document.
     * @type {string}
     * @memberof DocumentType
     */
    template: string;
    /**
     * Optional list of data sheet properties that are required by the template in order to render the document. This could be used as a validation mechanism when adding this document type to a product.
     * @type {Array<DatasheetPropertyKey>}
     * @memberof DocumentType
     */
    requiredProperties: Array<DatasheetPropertyKey>;
    /**
     * Object type that that this template requires. This will also determine at which phase the document is generated. Default is POLICY.
     * @type {string}
     * @memberof DocumentType
     */
    dataModel?: DocumentTypeDataModelEnum;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof DocumentType
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof DocumentType
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof DocumentType
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof DocumentType
     */
    _embedded?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentTypeDataModelEnum {
    QUOTE = 'QUOTE',
    POLICY = 'POLICY'
}

/**
 * DocumentType core attributes.
 * @export
 * @interface DocumentTypeBody
 */
export interface DocumentTypeBody {
    /**
     * Title or name of the document. Should be unique in the system.
     * @type {string}
     * @memberof DocumentTypeBody
     */
    name: string;
    /**
     * Name of the template that is used to generate the document.
     * @type {string}
     * @memberof DocumentTypeBody
     */
    template: string;
    /**
     * Optional list of data sheet properties that are required by the template in order to render the document. This could be used as a validation mechanism when adding this document type to a product.
     * @type {Array<DatasheetPropertyKey>}
     * @memberof DocumentTypeBody
     */
    requiredProperties: Array<DatasheetPropertyKey>;
    /**
     * Object type that that this template requires. This will also determine at which phase the document is generated. Default is POLICY.
     * @type {string}
     * @memberof DocumentTypeBody
     */
    dataModel?: DocumentTypeBodyDataModelEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentTypeBodyDataModelEnum {
    QUOTE = 'QUOTE',
    POLICY = 'POLICY'
}

/**
 * Reference to a document type resource.
 * @export
 * @interface DocumentTypeKey
 */
export interface DocumentTypeKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DocumentTypeKey
     */
    documentTypeId: string;
}
/**
 * Page of document-type resources
 * @export
 * @interface DocumentTypePagedModel
 */
export interface DocumentTypePagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof DocumentTypePagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalDocumentTypeListEmbedded}
     * @memberof DocumentTypePagedModel
     */
    _embedded?: HalDocumentTypeListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof DocumentTypePagedModel
     */
    page?: object;
}
/**
 * 
 * @export
 * @interface HalDocumentList
 */
export interface HalDocumentList {
    /**
     * 
     * @type {HalDocumentListEmbedded}
     * @memberof HalDocumentList
     */
    _embedded?: HalDocumentListEmbedded;
}
/**
 * 
 * @export
 * @interface HalDocumentListEmbedded
 */
export interface HalDocumentListEmbedded {
    /**
     * 
     * @type {Array<Document>}
     * @memberof HalDocumentListEmbedded
     */
    documents: Array<Document>;
}
/**
 * 
 * @export
 * @interface HalDocumentTypeList
 */
export interface HalDocumentTypeList {
    /**
     * 
     * @type {HalDocumentTypeListEmbedded}
     * @memberof HalDocumentTypeList
     */
    _embedded?: HalDocumentTypeListEmbedded;
}
/**
 * 
 * @export
 * @interface HalDocumentTypeListEmbedded
 */
export interface HalDocumentTypeListEmbedded {
    /**
     * 
     * @type {Array<DocumentType>}
     * @memberof HalDocumentTypeListEmbedded
     */
    documentTypes: Array<DocumentType>;
}
/**
 * Hypermedia link
 * @export
 * @interface HalLink
 */
export interface HalLink {
    /**
     * Hypertext reference
     * @type {string}
     * @memberof HalLink
     */
    href: string;
}
/**
 * 
 * @export
 * @interface HalPageLinks
 */
export interface HalPageLinks {
    /**
     * Link to first page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    first?: HalLink;
    /**
     * Link to next page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    next?: HalLink;
    /**
     * Link to previous page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    prev?: HalLink;
    /**
     * Link to last page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    last?: HalLink;
}
/**
 * HAL/Hypermedia page relations
 * @export
 * @interface HalPageTrait
 */
export interface HalPageTrait {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof HalPageTrait
     */
    _links?: HalPageLinks;
    /**
     * Page metadata.
     * @type {object}
     * @memberof HalPageTrait
     */
    page?: object;
}
/**
 * HAL/Hypermedia resource charactaristics.
 * @export
 * @interface HalResourceTrait
 */
export interface HalResourceTrait {
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _embedded?: { [key: string]: object; };
}
/**
 * HAL/Hypermedia Page
 * @export
 * @interface PagedModel
 */
export interface PagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof PagedModel
     */
    _links: HalPageLinks;
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof PagedModel
     */
    _embedded?: { [key: string]: object; };
    /**
     * Page metadata.
     * @type {object}
     * @memberof PagedModel
     */
    page?: object;
}
/**
 * Reference to a policy resource
 * @export
 * @interface PolicyKey
 */
export interface PolicyKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof PolicyKey
     */
    policyId: string;
}
/**
 * Reference to a quote resource
 * @export
 * @interface QuoteKey
 */
export interface QuoteKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof QuoteKey
     */
    quoteId: string;
}
/**
 * Resource with HAL/Hypermedia support
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Related platform tenant.
 * @export
 * @enum {string}
 */
export enum Tenant {
    INSHUR = 'INSHUR'
}


/**
 * EndPointsApi - axios parameter creator
 * @export
 */
export const EndPointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new document resource and the physical PDF file. Idempotent - will only create the document if not already existing, otherwise will return the existing document.
         * @summary Generate Document
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentRequest} [documentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument: async (xINSHURTenant?: Tenant, documentRequest?: DocumentRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/document`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentRequest !== undefined ? documentRequest : {}) : (documentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new document type/template configuration.  Required scope(s): ```admin``` 
         * @summary Create Document Type
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentTypeBody} [documentTypeBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentType: async (xINSHURTenant?: Tenant, documentTypeBody?: DocumentTypeBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/document-type`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentTypeBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentTypeBody !== undefined ? documentTypeBody : {}) : (documentTypeBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified document resource. Also deletes any linked PDF file.  Required scope(s): ```admin``` 
         * @summary Delete Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDocument.');
            }
            const localVarPath = `/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified document type resource. 
         * @summary Delete Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentType: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDocumentType.');
            }
            const localVarPath = `/document-type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified document resource.
         * @summary Get Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocument.');
            }
            const localVarPath = `/document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified document PDF.
         * @summary Download Document as PDF
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentPdf: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentPdf.');
            }
            const localVarPath = `/document/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified document type configuration.
         * @summary Get Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentType: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentType.');
            }
            const localVarPath = `/document-type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated dataset of document types with optional filter by datasheet property (Note -  the datasheetPropertyId and version must be supplied for this filter to be applied.).
         * @summary List Document Types
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {string} [daTasheetPropertyVersion] Version of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentTypes: async (xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, daTasheetPropertyVersion?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/document-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (datasheetPropertyId !== undefined) {
                localVarQueryParameter['datasheetPropertyId'] = datasheetPropertyId;
            }

            if (daTasheetPropertyVersion !== undefined) {
                localVarQueryParameter['da  tasheetPropertyVersion'] = daTasheetPropertyVersion;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated dataset of all documents.   Optional filters by policy, quote and user.  Additional permissions required to access documents not owned by the caller. 
         * @summary List Documents
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [policyId] Filter documents by specific policy.
         * @param {string} [quoteId] Filter documents by specific policy.
         * @param {string} [userId] Filter documents by specific user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsByPolicy: async (xINSHURTenant?: Tenant, size?: number, page?: number, policyId?: string, quoteId?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (policyId !== undefined) {
                localVarQueryParameter['policyId'] = policyId;
            }

            if (quoteId !== undefined) {
                localVarQueryParameter['quoteId'] = quoteId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires Role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndPointsApi - functional programming interface
 * @export
 */
export const EndPointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new document resource and the physical PDF file. Idempotent - will only create the document if not already existing, otherwise will return the existing document.
         * @summary Generate Document
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentRequest} [documentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocument(xINSHURTenant?: Tenant, documentRequest?: DocumentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createDocument(xINSHURTenant, documentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new document type/template configuration.  Required scope(s): ```admin``` 
         * @summary Create Document Type
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentTypeBody} [documentTypeBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentType(xINSHURTenant?: Tenant, documentTypeBody?: DocumentTypeBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentType>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createDocumentType(xINSHURTenant, documentTypeBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified document resource. Also deletes any linked PDF file.  Required scope(s): ```admin``` 
         * @summary Delete Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).deleteDocument(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified document type resource. 
         * @summary Delete Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentType(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).deleteDocumentType(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified document resource.
         * @summary Get Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocument(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getDocument(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified document PDF.
         * @summary Download Document as PDF
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentPdf(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getDocumentPdf(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified document type configuration.
         * @summary Get Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentType(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentType>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getDocumentType(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated dataset of document types with optional filter by datasheet property (Note -  the datasheetPropertyId and version must be supplied for this filter to be applied.).
         * @summary List Document Types
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {string} [daTasheetPropertyVersion] Version of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentTypes(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, daTasheetPropertyVersion?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTypePagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getDocumentTypes(xINSHURTenant, size, page, datasheetPropertyId, daTasheetPropertyVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated dataset of all documents.   Optional filters by policy, quote and user.  Additional permissions required to access documents not owned by the caller. 
         * @summary List Documents
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [policyId] Filter documents by specific policy.
         * @param {string} [quoteId] Filter documents by specific policy.
         * @param {string} [userId] Filter documents by specific user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentsByPolicy(xINSHURTenant?: Tenant, size?: number, page?: number, policyId?: string, quoteId?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getDocumentsByPolicy(xINSHURTenant, size, page, policyId, quoteId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires Role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EndPointsApi - factory interface
 * @export
 */
export const EndPointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new document resource and the physical PDF file. Idempotent - will only create the document if not already existing, otherwise will return the existing document.
         * @summary Generate Document
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentRequest} [documentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(xINSHURTenant?: Tenant, documentRequest?: DocumentRequest, options?: any): AxiosPromise<Document> {
            return EndPointsApiFp(configuration).createDocument(xINSHURTenant, documentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new document type/template configuration.  Required scope(s): ```admin``` 
         * @summary Create Document Type
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {DocumentTypeBody} [documentTypeBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentType(xINSHURTenant?: Tenant, documentTypeBody?: DocumentTypeBody, options?: any): AxiosPromise<DocumentType> {
            return EndPointsApiFp(configuration).createDocumentType(xINSHURTenant, documentTypeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified document resource. Also deletes any linked PDF file.  Required scope(s): ```admin``` 
         * @summary Delete Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<void> {
            return EndPointsApiFp(configuration).deleteDocument(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified document type resource. 
         * @summary Delete Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentType(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<void> {
            return EndPointsApiFp(configuration).deleteDocumentType(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified document resource.
         * @summary Get Document
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<Document> {
            return EndPointsApiFp(configuration).getDocument(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified document PDF.
         * @summary Download Document as PDF
         * @param {string} id Unique id of the document resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentPdf(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<any> {
            return EndPointsApiFp(configuration).getDocumentPdf(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified document type configuration.
         * @summary Get Document Type
         * @param {string} id Unique id of the document type resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentType(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<DocumentType> {
            return EndPointsApiFp(configuration).getDocumentType(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated dataset of document types with optional filter by datasheet property (Note -  the datasheetPropertyId and version must be supplied for this filter to be applied.).
         * @summary List Document Types
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {string} [daTasheetPropertyVersion] Version of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentTypes(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, daTasheetPropertyVersion?: string, options?: any): AxiosPromise<DocumentTypePagedModel> {
            return EndPointsApiFp(configuration).getDocumentTypes(xINSHURTenant, size, page, datasheetPropertyId, daTasheetPropertyVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated dataset of all documents.   Optional filters by policy, quote and user.  Additional permissions required to access documents not owned by the caller. 
         * @summary List Documents
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [policyId] Filter documents by specific policy.
         * @param {string} [quoteId] Filter documents by specific policy.
         * @param {string} [userId] Filter documents by specific user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentsByPolicy(xINSHURTenant?: Tenant, size?: number, page?: number, policyId?: string, quoteId?: string, userId?: string, options?: any): AxiosPromise<DocumentPagedModel> {
            return EndPointsApiFp(configuration).getDocumentsByPolicy(xINSHURTenant, size, page, policyId, quoteId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns internal service deployment metadata.  Requires Role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return EndPointsApiFp(configuration).getMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndPointsApi - object-oriented interface
 * @export
 * @class EndPointsApi
 * @extends {BaseAPI}
 */
export class EndPointsApi extends BaseAPI {
    /**
     * Creates a new document resource and the physical PDF file. Idempotent - will only create the document if not already existing, otherwise will return the existing document.
     * @summary Generate Document
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {DocumentRequest} [documentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createDocument(xINSHURTenant?: Tenant, documentRequest?: DocumentRequest, options?: any) {
        return EndPointsApiFp(this.configuration).createDocument(xINSHURTenant, documentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new document type/template configuration.  Required scope(s): ```admin``` 
     * @summary Create Document Type
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {DocumentTypeBody} [documentTypeBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createDocumentType(xINSHURTenant?: Tenant, documentTypeBody?: DocumentTypeBody, options?: any) {
        return EndPointsApiFp(this.configuration).createDocumentType(xINSHURTenant, documentTypeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified document resource. Also deletes any linked PDF file.  Required scope(s): ```admin``` 
     * @summary Delete Document
     * @param {string} id Unique id of the document resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public deleteDocument(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).deleteDocument(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified document type resource. 
     * @summary Delete Document Type
     * @param {string} id Unique id of the document type resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public deleteDocumentType(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).deleteDocumentType(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified document resource.
     * @summary Get Document
     * @param {string} id Unique id of the document resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getDocument(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getDocument(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified document PDF.
     * @summary Download Document as PDF
     * @param {string} id Unique id of the document resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getDocumentPdf(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getDocumentPdf(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified document type configuration.
     * @summary Get Document Type
     * @param {string} id Unique id of the document type resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getDocumentType(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getDocumentType(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated dataset of document types with optional filter by datasheet property (Note -  the datasheetPropertyId and version must be supplied for this filter to be applied.).
     * @summary List Document Types
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
     * @param {string} [daTasheetPropertyVersion] Version of the datasheet property resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getDocumentTypes(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, daTasheetPropertyVersion?: string, options?: any) {
        return EndPointsApiFp(this.configuration).getDocumentTypes(xINSHURTenant, size, page, datasheetPropertyId, daTasheetPropertyVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated dataset of all documents.   Optional filters by policy, quote and user.  Additional permissions required to access documents not owned by the caller. 
     * @summary List Documents
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {string} [policyId] Filter documents by specific policy.
     * @param {string} [quoteId] Filter documents by specific policy.
     * @param {string} [userId] Filter documents by specific user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getDocumentsByPolicy(xINSHURTenant?: Tenant, size?: number, page?: number, policyId?: string, quoteId?: string, userId?: string, options?: any) {
        return EndPointsApiFp(this.configuration).getDocumentsByPolicy(xINSHURTenant, size, page, policyId, quoteId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns internal service deployment metadata.  Requires Role(s): ```monitor``` 
     * @summary Service Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getMetadata(options?: any) {
        return EndPointsApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

}


