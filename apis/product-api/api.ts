// tslint:disable
/**
 * product-v1
 * Product API Schema
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * JSON API message.
 * @export
 * @interface ApiMessage
 */
export interface ApiMessage {
    /**
     * HTTP status code.
     * @type {number}
     * @memberof ApiMessage
     */
    status?: number;
    /**
     * HTTP status text.
     * @type {string}
     * @memberof ApiMessage
     */
    error?: string;
    /**
     * Custom message.
     * @type {string}
     * @memberof ApiMessage
     */
    message?: string;
}
/**
 * @type Auth0IdentityType
 * @export
 */
export type Auth0IdentityType = Auth0UberIdentity | Auth0UsernamePasswordIdentity;

/**
 * Auth0 \'Uber\' social identity
 * @export
 * @interface Auth0UberIdentity
 */
export interface Auth0UberIdentity {
    /**
     * 
     * @type {string}
     * @memberof Auth0UberIdentity
     */
    provider: Auth0UberIdentityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof Auth0UberIdentity
     */
    connection: Auth0UberIdentityConnectionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Auth0UberIdentityProviderEnum {
    Oauth2 = 'oauth2'
}
/**
    * @export
    * @enum {string}
    */
export enum Auth0UberIdentityConnectionEnum {
    Uber = 'uber'
}

/**
 * Auth0 \'Username-Password-Authentication\' identity
 * @export
 * @interface Auth0UsernamePasswordIdentity
 */
export interface Auth0UsernamePasswordIdentity {
    /**
     * 
     * @type {string}
     * @memberof Auth0UsernamePasswordIdentity
     */
    provider: Auth0UsernamePasswordIdentityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof Auth0UsernamePasswordIdentity
     */
    connection: Auth0UsernamePasswordIdentityConnectionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Auth0UsernamePasswordIdentityProviderEnum {
    Auth0 = 'auth0'
}
/**
    * @export
    * @enum {string}
    */
export enum Auth0UsernamePasswordIdentityConnectionEnum {
    UsernamePasswordAuthentication = 'Username-Password-Authentication'
}

/**
 * Collection of one or more coverage offers.
 * @export
 * @interface BasePackage
 */
export interface BasePackage {
    /**
     * Unique identifier for the package. Must be unique within the owning product.
     * @type {string}
     * @memberof BasePackage
     */
    packageId: string;
    /**
     * Name of the coverage package.
     * @type {string}
     * @memberof BasePackage
     */
    name: string;
}
/**
 * Configuration of notifications and correspondence.
 * @export
 * @interface Correspondence
 */
export interface Correspondence {
    /**
     * Configuration of new policy welcome notification.
     * @type {object}
     * @memberof Correspondence
     */
    policyCreated: object;
    /**
     * Configuration of policy expiry reminder notification.
     * @type {object}
     * @memberof Correspondence
     */
    policyExpiryReminder: object;
    /**
     * Configuration of policy cancellation notification.
     * @type {object}
     * @memberof Correspondence
     */
    policyCancelled: object;
}
/**
 * Supported insurance coverage.
 * @export
 * @interface Coverage
 */
export interface Coverage {
    /**
     * Unique identifier for the coverage. Must be unique within the owning product.
     * @type {string}
     * @memberof Coverage
     */
    coverageId: string;
    /**
     * Name of the coverage.
     * @type {string}
     * @memberof Coverage
     */
    name: string;
    /**
     * Summary of the coverage.
     * @type {string}
     * @memberof Coverage
     */
    description: string;
    /**
     * Minimum top limit of of cover available. The limit defined on CoverageOffers must be more than or equal to this amount.
     * @type {number}
     * @memberof Coverage
     */
    minLimit: number;
    /**
     * Maximum top limit of cover available. The limit defined on CoverageOffers must be more than or equal to this amount.
     * @type {number}
     * @memberof Coverage
     */
    maxLimit: number;
}
/**
 * Packaged coverage proposal with specific limit and excess values.
 * @export
 * @interface CoverageOffer
 */
export interface CoverageOffer {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof CoverageOffer
     */
    coverageId: string;
    /**
     * Maximum amount of coverage offered.
     * @type {number}
     * @memberof CoverageOffer
     */
    limit: number;
    /**
     * First portion of the value of a claim that the customer is liable for.
     * @type {number}
     * @memberof CoverageOffer
     */
    excess: number;
    /**
     * Indicates whether the rating engine must consider this coverage in the price calculation. When TRUE, the rating algorithm must define a rating model for this coverage. Default is TRUE.
     * @type {boolean}
     * @memberof CoverageOffer
     */
    rated?: boolean;
}
/**
 * 
 * @export
 * @interface CreatedTrait
 */
export interface CreatedTrait {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdBy: string;
}
/**
 * Supported currency. From ISO-4217 world currency codes.
 * @export
 * @enum {string}
 */
export enum Currency {
    GBP = 'GBP',
    USD = 'USD',
    EUR = 'EUR'
}

/**
 * Reference to a DatasheetProperty resource.
 * @export
 * @interface DatasheetPropertyKey
 */
export interface DatasheetPropertyKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    datasheetPropertyId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    version: string;
}
/**
 * Reference to a document type resource.
 * @export
 * @interface DocumentTypeKey
 */
export interface DocumentTypeKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DocumentTypeKey
     */
    documentTypeId: string;
}
/**
 * Driver lookup configuration.
 * @export
 * @interface DriverLookup
 */
export interface DriverLookup {
    /**
     * 
     * @type {DriverLookupProvider}
     * @memberof DriverLookup
     */
    provider: DriverLookupProvider;
    /**
     * Driver API URI (set by the backend based on the provider).
     * @type {string}
     * @memberof DriverLookup
     */
    uri?: string;
}
/**
 * Driver or drivers license lookup provider.
 * @export
 * @enum {string}
 */
export enum DriverLookupProvider {
    MYLICENCE = 'MYLICENCE'
}

/**
 * Product feature that controls the shape and behavior of policies.
 * @export
 * @interface FeatureKey
 */
export interface FeatureKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof FeatureKey
     */
    featureId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof FeatureKey
     */
    version: string;
}
/**
 * Hypermedia link
 * @export
 * @interface HalLink
 */
export interface HalLink {
    /**
     * Hypertext reference
     * @type {string}
     * @memberof HalLink
     */
    href: string;
}
/**
 * 
 * @export
 * @interface HalPageLinks
 */
export interface HalPageLinks {
    /**
     * Link to first page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    first?: HalLink;
    /**
     * Link to next page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    next?: HalLink;
    /**
     * Link to previous page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    prev?: HalLink;
    /**
     * Link to last page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    last?: HalLink;
}
/**
 * HAL/Hypermedia page relations
 * @export
 * @interface HalPageTrait
 */
export interface HalPageTrait {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof HalPageTrait
     */
    _links?: HalPageLinks;
    /**
     * Page metadata.
     * @type {object}
     * @memberof HalPageTrait
     */
    page?: object;
}
/**
 * 
 * @export
 * @interface HalProductList
 */
export interface HalProductList {
    /**
     * 
     * @type {HalProductListEmbedded}
     * @memberof HalProductList
     */
    _embedded?: HalProductListEmbedded;
}
/**
 * 
 * @export
 * @interface HalProductListEmbedded
 */
export interface HalProductListEmbedded {
    /**
     * 
     * @type {Array<Product>}
     * @memberof HalProductListEmbedded
     */
    products: Array<Product>;
}
/**
 * 
 * @export
 * @interface HalProductOptionList
 */
export interface HalProductOptionList {
    /**
     * 
     * @type {HalProductOptionListEmbedded}
     * @memberof HalProductOptionList
     */
    _embedded?: HalProductOptionListEmbedded;
}
/**
 * 
 * @export
 * @interface HalProductOptionListEmbedded
 */
export interface HalProductOptionListEmbedded {
    /**
     * 
     * @type {Array<ProductOption>}
     * @memberof HalProductOptionListEmbedded
     */
    product_options: Array<ProductOption>;
}
/**
 * HAL/Hypermedia resource charactaristics.
 * @export
 * @interface HalResourceTrait
 */
export interface HalResourceTrait {
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Insurance register settings.
 * @export
 * @interface InsuranceRegister
 */
export interface InsuranceRegister {
    /**
     * Set true to enable automatic notifications to the insurance register.
     * @type {boolean}
     * @memberof InsuranceRegister
     */
    enabled: boolean;
    /**
     * 
     * @type {RegisterProvider}
     * @memberof InsuranceRegister
     */
    registerProvider: RegisterProvider;
}
/**
 * Supported language. From ISO 639-2 world language codes.
 * @export
 * @enum {string}
 */
export enum Language {
    En = 'en',
    Nl = 'nl'
}

/**
 * 
 * @export
 * @interface LastModifiedTrait
 */
export interface LastModifiedTrait {
    /**
     * The UTC date-time stamp that the resource was last updated. Automatically set by the system.
     * @type {string}
     * @memberof LastModifiedTrait
     */
    lastModifiedOn: string;
    /**
     * Reference to the user or service that last updated the resource. Automatically set by the system.
     * @type {string}
     * @memberof LastModifiedTrait
     */
    lastModifiedBy: string;
}
/**
 * Supported geographical locations.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * ISO-3166-1 aplha2 world country codes
     * @type {string}
     * @memberof Location
     */
    country: LocationCountryEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LocationCountryEnum {
    GB = 'GB',
    US = 'US',
    NL = 'NL'
}

/**
 * Modifiable Resource with HAL/Hypermedia support
 * @export
 * @interface MutableResource
 */
export interface MutableResource {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof MutableResource
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof MutableResource
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof MutableResource
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof MutableResource
     */
    _embedded?: { [key: string]: object; };
    /**
     * The UTC date-time stamp that the resource was last updated. Automatically set by the system.
     * @type {string}
     * @memberof MutableResource
     */
    lastModifiedOn: string;
    /**
     * Reference to the user or service that last updated the resource. Automatically set by the system.
     * @type {string}
     * @memberof MutableResource
     */
    lastModifiedBy: string;
}
/**
 * Collection of one or more coverage offers.
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * Unique identifier for the package. Must be unique within the owning product.
     * @type {string}
     * @memberof Package
     */
    packageId: string;
    /**
     * Name of the coverage package.
     * @type {string}
     * @memberof Package
     */
    name: string;
    /**
     * 
     * @type {Array<CoverageOffer>}
     * @memberof Package
     */
    coverageOffers: Array<CoverageOffer>;
}
/**
 * 
 * @export
 * @interface PackageAllOf
 */
export interface PackageAllOf {
    /**
     * 
     * @type {Array<CoverageOffer>}
     * @memberof PackageAllOf
     */
    coverageOffers?: Array<CoverageOffer>;
}
/**
 * HAL/Hypermedia Page
 * @export
 * @interface PagedModel
 */
export interface PagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof PagedModel
     */
    _links: HalPageLinks;
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof PagedModel
     */
    _embedded?: { [key: string]: object; };
    /**
     * Page metadata.
     * @type {object}
     * @memberof PagedModel
     */
    page?: object;
}
/**
 * Defines the payment provider to use with this product
 * @export
 * @interface PaymentProvider
 */
export interface PaymentProvider {
    /**
     * Payment provider to use with this product
     * @type {string}
     * @memberof PaymentProvider
     */
    provider: PaymentProviderProviderEnum;
    /**
     * Payment method supported by this product
     * @type {Array<string>}
     * @memberof PaymentProvider
     */
    paymentMethods?: Array<PaymentProviderPaymentMethodsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentProviderProviderEnum {
    STRIPE = 'STRIPE'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentProviderPaymentMethodsEnum {
    CARD = 'CARD',
    IDEAL = 'IDEAL'
}

/**
 * Policy settings
 * @export
 * @interface PolicySettings
 */
export interface PolicySettings {
    /**
     * Maximum number of hours in the future that new policies can be set to start.
     * @type {number}
     * @memberof PolicySettings
     */
    maxStartLeadTimeHours: number;
    /**
     * Maximum number of hours before the end of a policy that a renewal of that policy can be initiated.
     * @type {number}
     * @memberof PolicySettings
     */
    maxRenewalLeadTimeHours?: number;
    /**
     * Maximum number of hours after a policy ends that a renewal of that policy can be set to start.
     * @type {number}
     * @memberof PolicySettings
     */
    maxAllowedBreakInCoverHours?: number;
}
/**
 * Product Resource
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof Product
     */
    productId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof Product
     */
    version: string;
    /**
     * 
     * @type {Tenant}
     * @memberof Product
     */
    tenant: Tenant;
    /**
     * Name of the product model.
     * @type {string}
     * @memberof Product
     */
    name: string;
    /**
     * 
     * @type {ProductType}
     * @memberof Product
     */
    type: ProductType;
    /**
     * Short product identitfier. Must be 3 capital letters.
     * @type {string}
     * @memberof Product
     */
    code: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof Product
     */
    status: ProductStatus;
    /**
     * 
     * @type {Array<Coverage>}
     * @memberof Product
     */
    coverages: Array<Coverage>;
    /**
     * Insurance coverage packages available on this product. The quote engine will use this to build a complete quote for new polices on this product.
     * @type {Array<Package>}
     * @memberof Product
     */
    packages: Array<Package>;
    /**
     * List of features supported on this product model. This list affects the policy business logic from data collection through to policy creation and life-cycle. Changes to this list would trigger a new version of the product and a regeneration of the data sheet schema.
     * @type {Array<ProductFeature>}
     * @memberof Product
     */
    features: Array<ProductFeature>;
    /**
     * 
     * @type {RatingAlgorithmKey}
     * @memberof Product
     */
    ratingAlgorithm: RatingAlgorithmKey;
    /**
     * Documents that must be generated for policies on this product.
     * @type {Array<ProductDocumentType>}
     * @memberof Product
     */
    documentTypes: Array<ProductDocumentType>;
    /**
     * 
     * @type {Location}
     * @memberof Product
     */
    location: Location;
    /**
     * 
     * @type {Currency}
     * @memberof Product
     */
    currency: Currency;
    /**
     * 
     * @type {Language}
     * @memberof Product
     */
    language: Language;
    /**
     * 
     * @type {Timezone}
     * @memberof Product
     */
    timezone: Timezone;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof Product
     */
    paymentProvider: PaymentProvider;
    /**
     * 
     * @type {Correspondence}
     * @memberof Product
     */
    correspondence: Correspondence;
    /**
     * 
     * @type {PolicySettings}
     * @memberof Product
     */
    policySettings: PolicySettings;
    /**
     * 
     * @type {SanctionsScreening}
     * @memberof Product
     */
    sanctionsScreening?: SanctionsScreening;
    /**
     * 
     * @type {InsuranceRegister}
     * @memberof Product
     */
    insuranceRegister?: InsuranceRegister;
    /**
     * 
     * @type {DriverLookup}
     * @memberof Product
     */
    driverLookup?: DriverLookup;
    /**
     * 
     * @type {VehicleLookup}
     * @memberof Product
     */
    vehicleLookup?: VehicleLookup;
    /**
     * List of possible identity types that customers must be authenticated with in order get a quote on this product. Customers only need to be authenticated with ONE OF the listed identity types. If not specified then it is assumed that there are no identity type restrictions on the product and it is available to any authenticated user.
     * @type {Array<Auth0IdentityType>}
     * @memberof Product
     */
    requiredIdentity?: Array<Auth0IdentityType>;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Product
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Product
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Product
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Product
     */
    _embedded?: { [key: string]: object; };
    /**
     * The UTC date-time stamp that the resource was last updated. Automatically set by the system.
     * @type {string}
     * @memberof Product
     */
    lastModifiedOn: string;
    /**
     * Reference to the user or service that last updated the resource. Automatically set by the system.
     * @type {string}
     * @memberof Product
     */
    lastModifiedBy: string;
}
/**
 * Product resource core data.
 * @export
 * @interface ProductBody
 */
export interface ProductBody {
    /**
     * 
     * @type {Tenant}
     * @memberof ProductBody
     */
    tenant: Tenant;
    /**
     * Name of the product model.
     * @type {string}
     * @memberof ProductBody
     */
    name: string;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductBody
     */
    type: ProductType;
    /**
     * Short product identitfier. Must be 3 capital letters.
     * @type {string}
     * @memberof ProductBody
     */
    code: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ProductBody
     */
    status: ProductStatus;
    /**
     * 
     * @type {Array<Coverage>}
     * @memberof ProductBody
     */
    coverages: Array<Coverage>;
    /**
     * Insurance coverage packages available on this product. The quote engine will use this to build a complete quote for new polices on this product.
     * @type {Array<Package>}
     * @memberof ProductBody
     */
    packages: Array<Package>;
    /**
     * List of features supported on this product model. This list affects the policy business logic from data collection through to policy creation and life-cycle. Changes to this list would trigger a new version of the product and a regeneration of the data sheet schema.
     * @type {Array<ProductFeature>}
     * @memberof ProductBody
     */
    features: Array<ProductFeature>;
    /**
     * 
     * @type {RatingAlgorithmKey}
     * @memberof ProductBody
     */
    ratingAlgorithm: RatingAlgorithmKey;
    /**
     * Documents that must be generated for policies on this product.
     * @type {Array<ProductDocumentType>}
     * @memberof ProductBody
     */
    documentTypes: Array<ProductDocumentType>;
    /**
     * 
     * @type {Location}
     * @memberof ProductBody
     */
    location: Location;
    /**
     * 
     * @type {Currency}
     * @memberof ProductBody
     */
    currency: Currency;
    /**
     * 
     * @type {Language}
     * @memberof ProductBody
     */
    language: Language;
    /**
     * 
     * @type {Timezone}
     * @memberof ProductBody
     */
    timezone: Timezone;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof ProductBody
     */
    paymentProvider: PaymentProvider;
    /**
     * 
     * @type {Correspondence}
     * @memberof ProductBody
     */
    correspondence: Correspondence;
    /**
     * 
     * @type {PolicySettings}
     * @memberof ProductBody
     */
    policySettings: PolicySettings;
    /**
     * 
     * @type {SanctionsScreening}
     * @memberof ProductBody
     */
    sanctionsScreening?: SanctionsScreening;
    /**
     * 
     * @type {InsuranceRegister}
     * @memberof ProductBody
     */
    insuranceRegister?: InsuranceRegister;
    /**
     * 
     * @type {DriverLookup}
     * @memberof ProductBody
     */
    driverLookup?: DriverLookup;
    /**
     * 
     * @type {VehicleLookup}
     * @memberof ProductBody
     */
    vehicleLookup?: VehicleLookup;
    /**
     * List of possible identity types that customers must be authenticated with in order get a quote on this product. Customers only need to be authenticated with ONE OF the listed identity types. If not specified then it is assumed that there are no identity type restrictions on the product and it is available to any authenticated user.
     * @type {Array<Auth0IdentityType>}
     * @memberof ProductBody
     */
    requiredIdentity?: Array<Auth0IdentityType>;
}
/**
 * Association of a documentType with a product.
 * @export
 * @interface ProductDocumentType
 */
export interface ProductDocumentType {
    /**
     * 
     * @type {DocumentTypeKey}
     * @memberof ProductDocumentType
     */
    documentType: DocumentTypeKey;
    /**
     * Indicates to which package the document type is associated. If not specified or null, the document will be generated for all policies created from this product. If set, the document will only be generated for policies based on the related package.
     * @type {string | object}
     * @memberof ProductDocumentType
     */
    packageId?: string | object;
}
/**
 * Join entity to associate a feature with a product.
 * @export
 * @interface ProductFeature
 */
export interface ProductFeature {
    /**
     * 
     * @type {FeatureKey}
     * @memberof ProductFeature
     */
    feature: FeatureKey;
    /**
     * Holds product-specific configuration for feature properties. Eg. Use this to set a specific pattern or format for a datasheet property for this product.
     * @type {Array<PropertyConfiguration>}
     * @memberof ProductFeature
     */
    propertyConfiguration: Array<PropertyConfiguration>;
    /**
     * Generic configuration object to provide configuration parameters to the feature.
     * @type {{ [key: string]: object; }}
     * @memberof ProductFeature
     */
    featureConfiguration?: { [key: string]: object; } | null;
}
/**
 * Reference to a product resource.
 * @export
 * @interface ProductKey
 */
export interface ProductKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof ProductKey
     */
    productId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof ProductKey
     */
    version: string;
}
/**
 * Readonly representation of an available product with it\'s customer identity requirements.
 * @export
 * @interface ProductOption
 */
export interface ProductOption extends ProductOptionBody {
}
/**
 * Product option resource core data.
 * @export
 * @interface ProductOptionBody
 */
export interface ProductOptionBody {
    /**
     * 
     * @type {ProductKey}
     * @memberof ProductOptionBody
     */
    product: ProductKey;
    /**
     * Name of the product.
     * @type {string}
     * @memberof ProductOptionBody
     */
    name: string;
    /**
     * Short product identitfier. Must be 3 capital letters.
     * @type {string}
     * @memberof ProductOptionBody
     */
    code: string;
    /**
     * List of possible identity types that customers must be authenticated with in order get a quote on this product. Customers only need to be authenticated with ONE OF the listed identity types. If not specified then it is assumed that there are no identity type restrictions on the product and it is available to any authenticated user.
     * @type {Array<Auth0IdentityType>}
     * @memberof ProductOptionBody
     */
    requiredIdentity?: Array<Auth0IdentityType>;
}
/**
 * Page of product option resources
 * @export
 * @interface ProductOptionPagedModel
 */
export interface ProductOptionPagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof ProductOptionPagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalProductOptionListEmbedded}
     * @memberof ProductOptionPagedModel
     */
    _embedded?: HalProductOptionListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof ProductOptionPagedModel
     */
    page?: object;
}
/**
 * Page of product resources
 * @export
 * @interface ProductPagedModel
 */
export interface ProductPagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof ProductPagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalProductListEmbedded}
     * @memberof ProductPagedModel
     */
    _embedded?: HalProductListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof ProductPagedModel
     */
    page?: object;
}
/**
 * Status of the product
 * @export
 * @enum {string}
 */
export enum ProductStatus {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE'
}

/**
 * Type of product. Taxi, Courier etc.
 * @export
 * @enum {string}
 */
export enum ProductType {
    TAXI = 'TAXI',
    COURIER = 'COURIER'
}

/**
 * Configuration for a datasheet property within the product feature.
 * @export
 * @interface PropertyConfiguration
 */
export interface PropertyConfiguration {
    /**
     * 
     * @type {DatasheetPropertyKey}
     * @memberof PropertyConfiguration
     */
    datasheetProperty: DatasheetPropertyKey;
    /**
     * List of allowed values for the property. Items in this list must comply with type and pattern. Used to generate a data sheet OAS3 schema.
     * @type {Array<string | number | boolean>}
     * @memberof PropertyConfiguration
     */
    allowedValues?: Array<string | number | boolean>;
    /**
     * Default value for the property. Assigned when it is added to the data sheet object. This value must comply with type, allowedValues and pattern. The value must comply with type.
     * @type {string | number | boolean}
     * @memberof PropertyConfiguration
     */
    defaultValue?: string | number | boolean;
    /**
     * Default pattern regex expression to validate the input. The value must comply with type and allowedValues.
     * @type {string}
     * @memberof PropertyConfiguration
     */
    pattern?: string;
    /**
     * JSON schema format. The value must comply with type, pattern and allowedValues.
     * @type {string}
     * @memberof PropertyConfiguration
     */
    format?: string;
}
/**
 * Reference to a RatingAlgorithm resource.
 * @export
 * @interface RatingAlgorithmKey
 */
export interface RatingAlgorithmKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof RatingAlgorithmKey
     */
    ratingAlgorithmId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof RatingAlgorithmKey
     */
    version: string;
}
/**
 * Insurance register service provider.
 * @export
 * @enum {string}
 */
export enum RegisterProvider {
    MDS = 'MDS'
}

/**
 * Resource with HAL/Hypermedia support
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Sanctions screening service provider
 * @export
 * @enum {string}
 */
export enum SanctionProvider {
    OFAC = 'OFAC'
}

/**
 * Sanctions screening settings
 * @export
 * @interface SanctionsScreening
 */
export interface SanctionsScreening {
    /**
     * Set true to enable sanctions checks before quote.
     * @type {boolean}
     * @memberof SanctionsScreening
     */
    enabled: boolean;
    /**
     * 
     * @type {SanctionProvider}
     * @memberof SanctionsScreening
     */
    sanctionProvider: SanctionProvider;
}
/**
 * Related platform tenant.
 * @export
 * @enum {string}
 */
export enum Tenant {
    INSHUR = 'INSHUR'
}

/**
 * Supported Timezone. From IANA Time Zone Database (TZDB). https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
 * @export
 * @enum {string}
 */
export enum Timezone {
    EuropeLondon = 'Europe/London',
    AmericaNewYork = 'America/New_York',
    EuropeAmsterdam = 'Europe/Amsterdam'
}

/**
 * Vehicle lookup configuration.
 * @export
 * @interface VehicleLookup
 */
export interface VehicleLookup {
    /**
     * 
     * @type {VehicleLookupProvider}
     * @memberof VehicleLookup
     */
    provider: VehicleLookupProvider;
    /**
     * Vehicle API URI (set by the backend based on the provider).
     * @type {string}
     * @memberof VehicleLookup
     */
    uri?: string;
}
/**
 * Vehicle lookup provider.
 * @export
 * @enum {string}
 */
export enum VehicleLookupProvider {
    CDL = 'CDL'
}


/**
 * EndPointsApi - axios parameter creator
 * @export
 */
export const EndPointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new product resource.
         * @summary Create Product
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (xINSHURTenant?: Tenant, productBody?: ProductBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productBody !== undefined ? productBody : {}) : (productBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version of a product resource.  The version is automatically calculated from the latest version.  TBC how to control a major or minor bump. 
         * @summary Create Product Version
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductVersion: async (id: string, xINSHURTenant?: Tenant, productBody?: ProductBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createProductVersion.');
            }
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productBody !== undefined ? productBody : {}) : (productBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified product configuration.  NOTE: will only allow the delete if the product is not linked to any quote or policy. 
         * @summary Delete Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, version: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProduct.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling deleteProduct.');
            }
            const localVarPath = `/product/{id}/v/{version}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified product configuration.
         * @summary Get Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, version: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProduct.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getProduct.');
            }
            const localVarPath = `/product/{id}/v/{version}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the datasheet JSON schema for the specified product.
         * @summary Get Datasheet Schema
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDatasheetSchema: async (id: string, version: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductDatasheetSchema.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getProductDatasheetSchema.');
            }
            const localVarPath = `/product/{id}/v/{version}/datasheet-schema`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the datasheet JSON schema for the latest version of the specified product.
         * @summary Get Datasheet Schema (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDatasheetSchemaLatestVersion: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductDatasheetSchemaLatestVersion.');
            }
            const localVarPath = `/product/{id}/datasheet-schema`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest version of the specified product configuration.
         * @summary Get Product (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductLatestVersion: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductLatestVersion.');
            }
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated dataset of product options. No authentication required. Provides a list of available products with their identity requirements so that UI applications can choose the correct authentication method for customers. Only ACTIVE product versions will be included.
         * @summary List Product Options
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductOptions: async (xINSHURTenant?: Tenant, size?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-options`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated dataset of products with optional filter by feature, package, rating algorithm, document type and status.
         * @summary List Products
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [featureId] Unique id of the feature resource.
         * @param {string} [featureVersion] Version of the feature resource.
         * @param {string} [ratingAlgorithmId] Unique id of the rating algorithm resource.
         * @param {string} [ratingAlgorithmVersion] Version of the rating algorithm resource.
         * @param {string} [documentTypeId] Unique id of the documentType resource.
         * @param {ProductStatus} [status] Product status (ACTIVE|INACTIVE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (xINSHURTenant?: Tenant, size?: number, page?: number, featureId?: string, featureVersion?: string, ratingAlgorithmId?: string, ratingAlgorithmVersion?: string, documentTypeId?: string, status?: ProductStatus, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (featureId !== undefined) {
                localVarQueryParameter['featureId'] = featureId;
            }

            if (featureVersion !== undefined) {
                localVarQueryParameter['featureVersion'] = featureVersion;
            }

            if (ratingAlgorithmId !== undefined) {
                localVarQueryParameter['ratingAlgorithmId'] = ratingAlgorithmId;
            }

            if (ratingAlgorithmVersion !== undefined) {
                localVarQueryParameter['ratingAlgorithmVersion'] = ratingAlgorithmVersion;
            }

            if (documentTypeId !== undefined) {
                localVarQueryParameter['documentTypeId'] = documentTypeId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of the specified product.
         * @summary Activate/Deactivate Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {ProductStatus} status Product status.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStatus: async (id: string, version: string, status: ProductStatus, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchStatus.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling patchStatus.');
            }
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling patchStatus.');
            }
            const localVarPath = `/product/{id}/v/{version}/status/{status}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndPointsApi - functional programming interface
 * @export
 */
export const EndPointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new product resource.
         * @summary Create Product
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createProduct(xINSHURTenant, productBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new version of a product resource.  The version is automatically calculated from the latest version.  TBC how to control a major or minor bump. 
         * @summary Create Product Version
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductVersion(id: string, xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createProductVersion(id, xINSHURTenant, productBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified product configuration.  NOTE: will only allow the delete if the product is not linked to any quote or policy. 
         * @summary Delete Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).deleteProduct(id, version, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified product configuration.
         * @summary Get Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProduct(id, version, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the datasheet JSON schema for the specified product.
         * @summary Get Datasheet Schema
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDatasheetSchema(id: string, version: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProductDatasheetSchema(id, version, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the datasheet JSON schema for the latest version of the specified product.
         * @summary Get Datasheet Schema (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductDatasheetSchemaLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProductDatasheetSchemaLatestVersion(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the latest version of the specified product configuration.
         * @summary Get Product (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProductLatestVersion(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated dataset of product options. No authentication required. Provides a list of available products with their identity requirements so that UI applications can choose the correct authentication method for customers. Only ACTIVE product versions will be included.
         * @summary List Product Options
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductOptions(xINSHURTenant?: Tenant, size?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOptionPagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProductOptions(xINSHURTenant, size, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated dataset of products with optional filter by feature, package, rating algorithm, document type and status.
         * @summary List Products
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [featureId] Unique id of the feature resource.
         * @param {string} [featureVersion] Version of the feature resource.
         * @param {string} [ratingAlgorithmId] Unique id of the rating algorithm resource.
         * @param {string} [ratingAlgorithmVersion] Version of the rating algorithm resource.
         * @param {string} [documentTypeId] Unique id of the documentType resource.
         * @param {ProductStatus} [status] Product status (ACTIVE|INACTIVE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(xINSHURTenant?: Tenant, size?: number, page?: number, featureId?: string, featureVersion?: string, ratingAlgorithmId?: string, ratingAlgorithmVersion?: string, documentTypeId?: string, status?: ProductStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getProducts(xINSHURTenant, size, page, featureId, featureVersion, ratingAlgorithmId, ratingAlgorithmVersion, documentTypeId, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the status of the specified product.
         * @summary Activate/Deactivate Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {ProductStatus} status Product status.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStatus(id: string, version: string, status: ProductStatus, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).patchStatus(id, version, status, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EndPointsApi - factory interface
 * @export
 */
export const EndPointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new product resource.
         * @summary Create Product
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any): AxiosPromise<Product> {
            return EndPointsApiFp(configuration).createProduct(xINSHURTenant, productBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version of a product resource.  The version is automatically calculated from the latest version.  TBC how to control a major or minor bump. 
         * @summary Create Product Version
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {ProductBody} [productBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductVersion(id: string, xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any): AxiosPromise<Product> {
            return EndPointsApiFp(configuration).createProductVersion(id, xINSHURTenant, productBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified product configuration.  NOTE: will only allow the delete if the product is not linked to any quote or policy. 
         * @summary Delete Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<void> {
            return EndPointsApiFp(configuration).deleteProduct(id, version, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return EndPointsApiFp(configuration).getMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified product configuration.
         * @summary Get Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<Product> {
            return EndPointsApiFp(configuration).getProduct(id, version, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the datasheet JSON schema for the specified product.
         * @summary Get Datasheet Schema
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDatasheetSchema(id: string, version: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<object> {
            return EndPointsApiFp(configuration).getProductDatasheetSchema(id, version, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the datasheet JSON schema for the latest version of the specified product.
         * @summary Get Datasheet Schema (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDatasheetSchemaLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<object> {
            return EndPointsApiFp(configuration).getProductDatasheetSchemaLatestVersion(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest version of the specified product configuration.
         * @summary Get Product (latest version)
         * @param {string} id Unique id of the product resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<Product> {
            return EndPointsApiFp(configuration).getProductLatestVersion(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated dataset of product options. No authentication required. Provides a list of available products with their identity requirements so that UI applications can choose the correct authentication method for customers. Only ACTIVE product versions will be included.
         * @summary List Product Options
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductOptions(xINSHURTenant?: Tenant, size?: number, page?: number, options?: any): AxiosPromise<ProductOptionPagedModel> {
            return EndPointsApiFp(configuration).getProductOptions(xINSHURTenant, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated dataset of products with optional filter by feature, package, rating algorithm, document type and status.
         * @summary List Products
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [featureId] Unique id of the feature resource.
         * @param {string} [featureVersion] Version of the feature resource.
         * @param {string} [ratingAlgorithmId] Unique id of the rating algorithm resource.
         * @param {string} [ratingAlgorithmVersion] Version of the rating algorithm resource.
         * @param {string} [documentTypeId] Unique id of the documentType resource.
         * @param {ProductStatus} [status] Product status (ACTIVE|INACTIVE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(xINSHURTenant?: Tenant, size?: number, page?: number, featureId?: string, featureVersion?: string, ratingAlgorithmId?: string, ratingAlgorithmVersion?: string, documentTypeId?: string, status?: ProductStatus, options?: any): AxiosPromise<ProductPagedModel> {
            return EndPointsApiFp(configuration).getProducts(xINSHURTenant, size, page, featureId, featureVersion, ratingAlgorithmId, ratingAlgorithmVersion, documentTypeId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of the specified product.
         * @summary Activate/Deactivate Product
         * @param {string} id Unique id of the product resource.
         * @param {string} version Version of the product resource.
         * @param {ProductStatus} status Product status.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStatus(id: string, version: string, status: ProductStatus, xINSHURTenant?: Tenant, options?: any): AxiosPromise<Product> {
            return EndPointsApiFp(configuration).patchStatus(id, version, status, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndPointsApi - object-oriented interface
 * @export
 * @class EndPointsApi
 * @extends {BaseAPI}
 */
export class EndPointsApi extends BaseAPI {
    /**
     * Creates a new product resource.
     * @summary Create Product
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {ProductBody} [productBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createProduct(xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any) {
        return EndPointsApiFp(this.configuration).createProduct(xINSHURTenant, productBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version of a product resource.  The version is automatically calculated from the latest version.  TBC how to control a major or minor bump. 
     * @summary Create Product Version
     * @param {string} id Unique id of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {ProductBody} [productBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createProductVersion(id: string, xINSHURTenant?: Tenant, productBody?: ProductBody, options?: any) {
        return EndPointsApiFp(this.configuration).createProductVersion(id, xINSHURTenant, productBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified product configuration.  NOTE: will only allow the delete if the product is not linked to any quote or policy. 
     * @summary Delete Product
     * @param {string} id Unique id of the product resource.
     * @param {string} version Version of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public deleteProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).deleteProduct(id, version, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
     * @summary Service Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getMetadata(options?: any) {
        return EndPointsApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified product configuration.
     * @summary Get Product
     * @param {string} id Unique id of the product resource.
     * @param {string} version Version of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProduct(id: string, version: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getProduct(id, version, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the datasheet JSON schema for the specified product.
     * @summary Get Datasheet Schema
     * @param {string} id Unique id of the product resource.
     * @param {string} version Version of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProductDatasheetSchema(id: string, version: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getProductDatasheetSchema(id, version, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the datasheet JSON schema for the latest version of the specified product.
     * @summary Get Datasheet Schema (latest version)
     * @param {string} id Unique id of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProductDatasheetSchemaLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getProductDatasheetSchemaLatestVersion(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest version of the specified product configuration.
     * @summary Get Product (latest version)
     * @param {string} id Unique id of the product resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProductLatestVersion(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getProductLatestVersion(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated dataset of product options. No authentication required. Provides a list of available products with their identity requirements so that UI applications can choose the correct authentication method for customers. Only ACTIVE product versions will be included.
     * @summary List Product Options
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProductOptions(xINSHURTenant?: Tenant, size?: number, page?: number, options?: any) {
        return EndPointsApiFp(this.configuration).getProductOptions(xINSHURTenant, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated dataset of products with optional filter by feature, package, rating algorithm, document type and status.
     * @summary List Products
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {string} [featureId] Unique id of the feature resource.
     * @param {string} [featureVersion] Version of the feature resource.
     * @param {string} [ratingAlgorithmId] Unique id of the rating algorithm resource.
     * @param {string} [ratingAlgorithmVersion] Version of the rating algorithm resource.
     * @param {string} [documentTypeId] Unique id of the documentType resource.
     * @param {ProductStatus} [status] Product status (ACTIVE|INACTIVE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getProducts(xINSHURTenant?: Tenant, size?: number, page?: number, featureId?: string, featureVersion?: string, ratingAlgorithmId?: string, ratingAlgorithmVersion?: string, documentTypeId?: string, status?: ProductStatus, options?: any) {
        return EndPointsApiFp(this.configuration).getProducts(xINSHURTenant, size, page, featureId, featureVersion, ratingAlgorithmId, ratingAlgorithmVersion, documentTypeId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of the specified product.
     * @summary Activate/Deactivate Product
     * @param {string} id Unique id of the product resource.
     * @param {string} version Version of the product resource.
     * @param {ProductStatus} status Product status.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public patchStatus(id: string, version: string, status: ProductStatus, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).patchStatus(id, version, status, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

}


