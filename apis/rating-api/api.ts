// tslint:disable
/**
 * rating-v1
 * Rating API Schema
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AbstractRatingRule
 */
export interface AbstractRatingRule {
    /**
     * This is the rule name used for human readibility when looking at rules.
     * @type {string}
     * @memberof AbstractRatingRule
     */
    name: string;
    /**
     * A wordy summary of the rule to help people understand what on earth it does.
     * @type {string}
     * @memberof AbstractRatingRule
     */
    description: string;
    /**
     * Type of rule. LOOKUP, DYNAMIC or FACTOR.
     * @type {string}
     * @memberof AbstractRatingRule
     */
    type: AbstractRatingRuleTypeEnum;
    /**
     * The order the rule needs to be processed.
     * @type {number}
     * @memberof AbstractRatingRule
     */
    order: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AbstractRatingRuleTypeEnum {
    LOOKUP = 'LOOKUP',
    DYNAMIC = 'DYNAMIC',
    FACTOR = 'FACTOR'
}

/**
 * JSON API message.
 * @export
 * @interface ApiMessage
 */
export interface ApiMessage {
    /**
     * HTTP status code.
     * @type {number}
     * @memberof ApiMessage
     */
    status?: number;
    /**
     * HTTP status text.
     * @type {string}
     * @memberof ApiMessage
     */
    error?: string;
    /**
     * Custom message.
     * @type {string}
     * @memberof ApiMessage
     */
    message?: string;
}
/**
 * Collection of one or more coverage offers.
 * @export
 * @interface BasePackage
 */
export interface BasePackage {
    /**
     * Unique identifier for the package. Must be unique within the owning product.
     * @type {string}
     * @memberof BasePackage
     */
    packageId: string;
    /**
     * Name of the coverage package.
     * @type {string}
     * @memberof BasePackage
     */
    name: string;
}
/**
 * Packaged coverage proposal with specific limit and excess values.
 * @export
 * @interface CoverageOffer
 */
export interface CoverageOffer {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof CoverageOffer
     */
    coverageId: string;
    /**
     * Maximum amount of coverage offered.
     * @type {number}
     * @memberof CoverageOffer
     */
    limit: number;
    /**
     * First portion of the value of a claim that the customer is liable for.
     * @type {number}
     * @memberof CoverageOffer
     */
    excess: number;
    /**
     * Indicates whether the rating engine must consider this coverage in the price calculation. When TRUE, the rating algorithm must define a rating model for this coverage. Default is TRUE.
     * @type {boolean}
     * @memberof CoverageOffer
     */
    rated?: boolean;
}
/**
 * 
 * @export
 * @interface CreatedTrait
 */
export interface CreatedTrait {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdBy: string;
}
/**
 * Reference to a DatasheetProperty resource.
 * @export
 * @interface DatasheetPropertyKey
 */
export interface DatasheetPropertyKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    datasheetPropertyId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof DatasheetPropertyKey
     */
    version: string;
}
/**
 * DYNAMIC RULE - Rule that uses a function to calculate a price.
 * @export
 * @interface DynamicRule
 */
export interface DynamicRule {
    /**
     * The fully qualified class name of the function that will perform the rating.
     * @type {string}
     * @memberof DynamicRule
     */
    executorClassName: string;
    /**
     * Indicates whether the executor function has determined that that the coverage is an acceptable risk based on the factors. Quote should decline if this is false.
     * @type {boolean}
     * @memberof DynamicRule
     */
    acceptable: boolean | null;
    /**
     * Indicates whether the executor function completed successfully.
     * @type {boolean}
     * @memberof DynamicRule
     */
    successful: boolean | null;
    /**
     * Indicates whether the rule was processed or not
     * @type {string}
     * @memberof DynamicRule
     */
    status: DynamicRuleStatusEnum;
    /**
     * Context data returned by the executor function after processing.
     * @type {object}
     * @memberof DynamicRule
     */
    data: object | null;
    /**
     * This is the rule name used for human readibility when looking at rules.
     * @type {string}
     * @memberof DynamicRule
     */
    name: string;
    /**
     * A wordy summary of the rule to help people understand what on earth it does.
     * @type {string}
     * @memberof DynamicRule
     */
    description: string;
    /**
     * Type of rule. LOOKUP, DYNAMIC or FACTOR.
     * @type {string}
     * @memberof DynamicRule
     */
    type: DynamicRuleTypeEnum;
    /**
     * The order the rule needs to be processed.
     * @type {number}
     * @memberof DynamicRule
     */
    order: number;
    /**
     * multiplicative essentially multiplies the base rate by the value in the matched rule, additive adds the value in the matched rule to the base rate (i.e a currency value) 
     * @type {string}
     * @memberof DynamicRule
     */
    processingMethod: DynamicRuleProcessingMethodEnum;
    /**
     * Zero-decimal currency. The rate when this rule started processing (i.e. the base rate, plus the adjustments made by the previous rules) - used when analysing how a rule was applied.
     * @type {number}
     * @memberof DynamicRule
     */
    input: number | null;
    /**
     * Zero-decimal currency. The result of processing the rule (i.e. what is the current price after the rate has been modified by this rule).
     * @type {number}
     * @memberof DynamicRule
     */
    result: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DynamicRuleStatusEnum {
    SKIPPED = 'SKIPPED',
    PROCESSED = 'PROCESSED'
}
/**
    * @export
    * @enum {string}
    */
export enum DynamicRuleTypeEnum {
    LOOKUP = 'LOOKUP',
    DYNAMIC = 'DYNAMIC',
    FACTOR = 'FACTOR'
}
/**
    * @export
    * @enum {string}
    */
export enum DynamicRuleProcessingMethodEnum {
    ADDITIVE = 'ADDITIVE',
    MULTIPLICATIVE = 'MULTIPLICATIVE'
}

/**
 * FACTOR RULE - Rule used to generate a calculated factor based on a lookup table.
 * @export
 * @interface FactorRule
 */
export interface FactorRule {
    /**
     * Reference to the calculated factor. Subsequent rules in the rating model can access calculated factors using this reference.
     * @type {string}
     * @memberof FactorRule
     */
    calculatedFactorId: string;
    /**
     * This is the rule name used for human readibility when looking at rules.
     * @type {string}
     * @memberof FactorRule
     */
    name: string;
    /**
     * A wordy summary of the rule to help people understand what on earth it does.
     * @type {string}
     * @memberof FactorRule
     */
    description: string;
    /**
     * Type of rule. LOOKUP, DYNAMIC or FACTOR.
     * @type {string}
     * @memberof FactorRule
     */
    type: FactorRuleTypeEnum;
    /**
     * The order the rule needs to be processed.
     * @type {number}
     * @memberof FactorRule
     */
    order: number;
    /**
     * 
     * @type {RatingTable}
     * @memberof FactorRule
     */
    ratingTable: RatingTable;
}

/**
    * @export
    * @enum {string}
    */
export enum FactorRuleTypeEnum {
    LOOKUP = 'LOOKUP',
    DYNAMIC = 'DYNAMIC',
    FACTOR = 'FACTOR'
}

/**
 * Hypermedia link
 * @export
 * @interface HalLink
 */
export interface HalLink {
    /**
     * Hypertext reference
     * @type {string}
     * @memberof HalLink
     */
    href: string;
}
/**
 * 
 * @export
 * @interface HalPageLinks
 */
export interface HalPageLinks {
    /**
     * Link to first page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    first?: HalLink;
    /**
     * Link to next page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    next?: HalLink;
    /**
     * Link to previous page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    prev?: HalLink;
    /**
     * Link to last page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    last?: HalLink;
}
/**
 * HAL/Hypermedia page relations
 * @export
 * @interface HalPageTrait
 */
export interface HalPageTrait {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof HalPageTrait
     */
    _links?: HalPageLinks;
    /**
     * Page metadata.
     * @type {object}
     * @memberof HalPageTrait
     */
    page?: object;
}
/**
 * 
 * @export
 * @interface HalRatingAlgorithmList
 */
export interface HalRatingAlgorithmList {
    /**
     * 
     * @type {HalRatingAlgorithmListEmbedded}
     * @memberof HalRatingAlgorithmList
     */
    _embedded?: HalRatingAlgorithmListEmbedded;
}
/**
 * 
 * @export
 * @interface HalRatingAlgorithmListEmbedded
 */
export interface HalRatingAlgorithmListEmbedded {
    /**
     * 
     * @type {Array<RatingAlgorithm>}
     * @memberof HalRatingAlgorithmListEmbedded
     */
    ratingAlgorithms: Array<RatingAlgorithm>;
}
/**
 * HAL/Hypermedia resource charactaristics.
 * @export
 * @interface HalResourceTrait
 */
export interface HalResourceTrait {
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _embedded?: { [key: string]: object; };
}
/**
 * LOOKUP RULE - Rule that uses a multi-dimensional lookup table to calculate a price.
 * @export
 * @interface LookupRule
 */
export interface LookupRule {
    /**
     * This is the rule name used for human readibility when looking at rules.
     * @type {string}
     * @memberof LookupRule
     */
    name: string;
    /**
     * A wordy summary of the rule to help people understand what on earth it does.
     * @type {string}
     * @memberof LookupRule
     */
    description: string;
    /**
     * Type of rule. LOOKUP, DYNAMIC or FACTOR.
     * @type {string}
     * @memberof LookupRule
     */
    type: LookupRuleTypeEnum;
    /**
     * The order the rule needs to be processed.
     * @type {number}
     * @memberof LookupRule
     */
    order: number;
    /**
     * multiplicative essentially multiplies the base rate by the value in the matched rule, additive adds the value in the matched rule to the base rate (i.e a currency value) 
     * @type {string}
     * @memberof LookupRule
     */
    processingMethod: LookupRuleProcessingMethodEnum;
    /**
     * Zero-decimal currency. The rate when this rule started processing (i.e. the base rate, plus the adjustments made by the previous rules) - used when analysing how a rule was applied.
     * @type {number}
     * @memberof LookupRule
     */
    input: number | null;
    /**
     * Zero-decimal currency. The result of processing the rule (i.e. what is the current price after the rate has been modified by this rule).
     * @type {number}
     * @memberof LookupRule
     */
    result: number | null;
    /**
     * 
     * @type {RatingTable}
     * @memberof LookupRule
     */
    ratingTable: RatingTable;
}

/**
    * @export
    * @enum {string}
    */
export enum LookupRuleTypeEnum {
    LOOKUP = 'LOOKUP',
    DYNAMIC = 'DYNAMIC',
    FACTOR = 'FACTOR'
}
/**
    * @export
    * @enum {string}
    */
export enum LookupRuleProcessingMethodEnum {
    ADDITIVE = 'ADDITIVE',
    MULTIPLICATIVE = 'MULTIPLICATIVE'
}

/**
 * 
 * @export
 * @interface LookupRuleTrait
 */
export interface LookupRuleTrait {
    /**
     * 
     * @type {RatingTable}
     * @memberof LookupRuleTrait
     */
    ratingTable: RatingTable;
}
/**
 * Collection of one or more coverage offers.
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * Unique identifier for the package. Must be unique within the owning product.
     * @type {string}
     * @memberof Package
     */
    packageId: string;
    /**
     * Name of the coverage package.
     * @type {string}
     * @memberof Package
     */
    name: string;
    /**
     * 
     * @type {Array<CoverageOffer>}
     * @memberof Package
     */
    coverageOffers: Array<CoverageOffer>;
}
/**
 * 
 * @export
 * @interface PackageAllOf
 */
export interface PackageAllOf {
    /**
     * 
     * @type {Array<CoverageOffer>}
     * @memberof PackageAllOf
     */
    coverageOffers?: Array<CoverageOffer>;
}
/**
 * HAL/Hypermedia Page
 * @export
 * @interface PagedModel
 */
export interface PagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof PagedModel
     */
    _links: HalPageLinks;
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof PagedModel
     */
    _embedded?: { [key: string]: object; };
    /**
     * Page metadata.
     * @type {object}
     * @memberof PagedModel
     */
    page?: object;
}
/**
 * 
 * @export
 * @interface PriceRuleTrait
 */
export interface PriceRuleTrait {
    /**
     * multiplicative essentially multiplies the base rate by the value in the matched rule, additive adds the value in the matched rule to the base rate (i.e a currency value) 
     * @type {string}
     * @memberof PriceRuleTrait
     */
    processingMethod: PriceRuleTraitProcessingMethodEnum;
    /**
     * Zero-decimal currency. The rate when this rule started processing (i.e. the base rate, plus the adjustments made by the previous rules) - used when analysing how a rule was applied.
     * @type {number}
     * @memberof PriceRuleTrait
     */
    input: number | null;
    /**
     * Zero-decimal currency. The result of processing the rule (i.e. what is the current price after the rate has been modified by this rule).
     * @type {number}
     * @memberof PriceRuleTrait
     */
    result: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PriceRuleTraitProcessingMethodEnum {
    ADDITIVE = 'ADDITIVE',
    MULTIPLICATIVE = 'MULTIPLICATIVE'
}

/**
 * Rating resource
 * @export
 * @interface Rating
 */
export interface Rating {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof Rating
     */
    ratingId: string;
    /**
     * 
     * @type {RatingAlgorithmKey}
     * @memberof Rating
     */
    ratingAlgorithm: RatingAlgorithmKey;
    /**
     * Set of data on which the rating is based.
     * @type {any}
     * @memberof Rating
     */
    datasheet: any;
    /**
     * The package that has been rated.
     * @type {Package}
     * @memberof Rating
     */
    package: Package;
    /**
     * Processed rating models for each of the coverage offers in the package. These contain the rating rules as well as the results for each coverage.
     * @type {Array<RatingModel>}
     * @memberof Rating
     */
    ratingModels: Array<RatingModel>;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Rating
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Rating
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Rating
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Rating
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Algorithm to calculate a price based on a coverage package and datasheet.
 * @export
 * @interface RatingAlgorithm
 */
export interface RatingAlgorithm {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    ratingAlgorithmId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    version: string;
    /**
     * Name of the algorithm.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    name: string;
    /**
     * Description of the algorithm.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    description: string;
    /**
     * Reference to the Java class that implements the rating logic. NOTE: This must be versioned along with the algorithm configuration so that previous versions of the algorithm logic can be maintained for MTAs. 
     * @type {string}
     * @memberof RatingAlgorithm
     */
    className: string;
    /**
     * 
     * @type {Array<RatingModel>}
     * @memberof RatingAlgorithm
     */
    ratingModels: Array<RatingModel>;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof RatingAlgorithm
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof RatingAlgorithm
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof RatingAlgorithm
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Rating algorithm core data.
 * @export
 * @interface RatingAlgorithmBody
 */
export interface RatingAlgorithmBody {
    /**
     * Name of the algorithm.
     * @type {string}
     * @memberof RatingAlgorithmBody
     */
    name: string;
    /**
     * Description of the algorithm.
     * @type {string}
     * @memberof RatingAlgorithmBody
     */
    description: string;
    /**
     * Reference to the Java class that implements the rating logic. NOTE: This must be versioned along with the algorithm configuration so that previous versions of the algorithm logic can be maintained for MTAs. 
     * @type {string}
     * @memberof RatingAlgorithmBody
     */
    className: string;
    /**
     * 
     * @type {Array<RatingModel>}
     * @memberof RatingAlgorithmBody
     */
    ratingModels: Array<RatingModel>;
}
/**
 * Reference to a RatingAlgorithm resource.
 * @export
 * @interface RatingAlgorithmKey
 */
export interface RatingAlgorithmKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof RatingAlgorithmKey
     */
    ratingAlgorithmId: string;
    /**
     * Major.Minor version number.
     * @type {string}
     * @memberof RatingAlgorithmKey
     */
    version: string;
}
/**
 * Page of RatingAlgorithm resources
 * @export
 * @interface RatingAlgorithmPagedModel
 */
export interface RatingAlgorithmPagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof RatingAlgorithmPagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalRatingAlgorithmListEmbedded}
     * @memberof RatingAlgorithmPagedModel
     */
    _embedded?: HalRatingAlgorithmListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof RatingAlgorithmPagedModel
     */
    page?: object;
}
/**
 * Rating resource body
 * @export
 * @interface RatingBody
 */
export interface RatingBody {
    /**
     * 
     * @type {RatingAlgorithmKey}
     * @memberof RatingBody
     */
    ratingAlgorithm: RatingAlgorithmKey;
    /**
     * Set of data on which the rating is based.
     * @type {any}
     * @memberof RatingBody
     */
    datasheet: any;
    /**
     * The package that has been rated.
     * @type {Package}
     * @memberof RatingBody
     */
    package: Package;
    /**
     * Processed rating models for each of the coverage offers in the package. These contain the rating rules as well as the results for each coverage.
     * @type {Array<RatingModel>}
     * @memberof RatingBody
     */
    ratingModels: Array<RatingModel>;
}
/**
 * Reference to a rating resource
 * @export
 * @interface RatingKey
 */
export interface RatingKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof RatingKey
     */
    ratingId: string;
}
/**
 * Rating configuration
 * @export
 * @interface RatingModel
 */
export interface RatingModel {
    /**
     * Human friendly explaination for this model.
     * @type {string}
     * @memberof RatingModel
     */
    description?: string;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof RatingModel
     */
    coverageId: string;
    /**
     * Zero-decimal currency. The base rate is essentially the starting rate which is defined per coverage.
     * @type {number}
     * @memberof RatingModel
     */
    baseRate: number;
    /**
     * The IPT percentage for this coverage.
     * @type {number}
     * @memberof RatingModel
     */
    taxRate: number;
    /**
     * Zero-decimal currency. Specifies the minimum premium we should charge for this rate.
     * @type {number}
     * @memberof RatingModel
     */
    minPremium: number;
    /**
     * Zero-decimal currency. Specifies the maximum premium we should charge for this rate.
     * @type {number}
     * @memberof RatingModel
     */
    maxPremium: number;
    /**
     * This is the list of rules which are followed to create a total premium for the coverage.
     * @type {Array<LookupRule | DynamicRule | FactorRule>}
     * @memberof RatingModel
     */
    rules: Array<LookupRule | DynamicRule | FactorRule>;
    /**
     * Zero-decimal currency. After all the rules have been processed in this coverage, the final value of the cost of this coverage excluding tax.
     * @type {number}
     * @memberof RatingModel
     */
    finalRate: number | null;
    /**
     * Zero-decimal currency. IPT amount that will be charged. Calculated from finalRate.
     * @type {number}
     * @memberof RatingModel
     */
    finalTax: number | null;
}
/**
 * Request for a rating.
 * @export
 * @interface RatingRequest
 */
export interface RatingRequest {
    /**
     * 
     * @type {RatingAlgorithmKey}
     * @memberof RatingRequest
     */
    ratingAlgorithm: RatingAlgorithmKey;
    /**
     * Set of data on which the rating is based. Must contain the required algorithm rating factors.
     * @type {any}
     * @memberof RatingRequest
     */
    datasheet: any;
    /**
     * 
     * @type {Package}
     * @memberof RatingRequest
     */
    package: Package;
}
/**
 * Representation of a multi-dimensional table to determine rating factor weightings based on property values in the datasheet and package configuration.
 * @export
 * @interface RatingTable
 */
export interface RatingTable {
    /**
     * List of rating factors used in the table. Eg. in a two dimensional table, this list will have two factors defined.
     * @type {Array<object>}
     * @memberof RatingTable
     */
    factors: Array<object>;
    /**
     * Defines the weightings for each factor combination defined in the factors array. The number of combinations must be the number of factors to the power of 2. Eg. if there are two factors defined then there will be four lookups.
     * @type {Array<object>}
     * @memberof RatingTable
     */
    lookups: Array<object>;
}
/**
 * Resource with HAL/Hypermedia support
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _embedded?: { [key: string]: object; };
}
/**
 * Related platform tenant.
 * @export
 * @enum {string}
 */
export enum Tenant {
    INSHUR = 'INSHUR'
}


/**
 * EndPointsApi - axios parameter creator
 * @export
 */
export const EndPointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a rating for a specified package and datasheet.
         * @summary Rate Package
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingRequest} [ratingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRating: async (xINSHURTenant?: Tenant, ratingRequest?: RatingRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rating`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ratingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ratingRequest !== undefined ? ratingRequest : {}) : (ratingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new rating algorithm resource.
         * @summary Create Rating Algorithm
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRatingAlgorithm: async (xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rating-algorithm`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ratingAlgorithmBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ratingAlgorithmBody !== undefined ? ratingAlgorithmBody : {}) : (ratingAlgorithmBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version of a rating algorithm resource.  The version is automatically calculated from the latest version. TBC how to control a major or minor bump. 
         * @summary Create Rating Algorithm Version
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRatingAlgorithmVersion: async (id: string, xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createRatingAlgorithmVersion.');
            }
            const localVarPath = `/rating-algorithm/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ratingAlgorithmBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ratingAlgorithmBody !== undefined ? ratingAlgorithmBody : {}) : (ratingAlgorithmBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified rating algorithm configuration.  NOTE: will only allow the delete if the algorithm is not linked to any product. 
         * @summary Delete Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRatingAlgorithm: async (id: string, version: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRatingAlgorithm.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling deleteRatingAlgorithm.');
            }
            const localVarPath = `/rating-algorithm/{id}/v/{version}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest version of specified rating algorithm definition.
         * @summary Get Rating Algorithm (latest version)
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRatingAlgorithm: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLatestRatingAlgorithm.');
            }
            const localVarPath = `/rating-algorithm/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns existing calculated rating.
         * @summary Retrieve Rating
         * @param {string} id Unique id of the rating resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRating: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRating.');
            }
            const localVarPath = `/rating/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified rating algorithm configuration.
         * @summary Get Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingAlgorithm: async (id: string, version: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRatingAlgorithm.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getRatingAlgorithm.');
            }
            const localVarPath = `/rating-algorithm/{id}/v/{version}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated data set rating algorithm resources with optional filter by datasheet property.
         * @summary List Rating Algorithms
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingAlgorithms: async (xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rating-algorithms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (datasheetPropertyId !== undefined) {
                localVarQueryParameter['datasheetPropertyId'] = datasheetPropertyId;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndPointsApi - functional programming interface
 * @export
 */
export const EndPointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generates a rating for a specified package and datasheet.
         * @summary Rate Package
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingRequest} [ratingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRating(xINSHURTenant?: Tenant, ratingRequest?: RatingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createRating(xINSHURTenant, ratingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new rating algorithm resource.
         * @summary Create Rating Algorithm
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRatingAlgorithm(xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAlgorithm>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createRatingAlgorithm(xINSHURTenant, ratingAlgorithmBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new version of a rating algorithm resource.  The version is automatically calculated from the latest version. TBC how to control a major or minor bump. 
         * @summary Create Rating Algorithm Version
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRatingAlgorithmVersion(id: string, xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAlgorithm>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createRatingAlgorithmVersion(id, xINSHURTenant, ratingAlgorithmBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified rating algorithm configuration.  NOTE: will only allow the delete if the algorithm is not linked to any product. 
         * @summary Delete Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).deleteRatingAlgorithm(id, version, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the latest version of specified rating algorithm definition.
         * @summary Get Rating Algorithm (latest version)
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestRatingAlgorithm(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAlgorithm>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getLatestRatingAlgorithm(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns existing calculated rating.
         * @summary Retrieve Rating
         * @param {string} id Unique id of the rating resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRating(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getRating(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified rating algorithm configuration.
         * @summary Get Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAlgorithm>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getRatingAlgorithm(id, version, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated data set rating algorithm resources with optional filter by datasheet property.
         * @summary List Rating Algorithms
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingAlgorithms(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingAlgorithmPagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getRatingAlgorithms(xINSHURTenant, size, page, datasheetPropertyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EndPointsApi - factory interface
 * @export
 */
export const EndPointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Generates a rating for a specified package and datasheet.
         * @summary Rate Package
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingRequest} [ratingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRating(xINSHURTenant?: Tenant, ratingRequest?: RatingRequest, options?: any): AxiosPromise<Rating> {
            return EndPointsApiFp(configuration).createRating(xINSHURTenant, ratingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rating algorithm resource.
         * @summary Create Rating Algorithm
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRatingAlgorithm(xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any): AxiosPromise<RatingAlgorithm> {
            return EndPointsApiFp(configuration).createRatingAlgorithm(xINSHURTenant, ratingAlgorithmBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version of a rating algorithm resource.  The version is automatically calculated from the latest version. TBC how to control a major or minor bump. 
         * @summary Create Rating Algorithm Version
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRatingAlgorithmVersion(id: string, xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any): AxiosPromise<RatingAlgorithm> {
            return EndPointsApiFp(configuration).createRatingAlgorithmVersion(id, xINSHURTenant, ratingAlgorithmBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified rating algorithm configuration.  NOTE: will only allow the delete if the algorithm is not linked to any product. 
         * @summary Delete Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<void> {
            return EndPointsApiFp(configuration).deleteRatingAlgorithm(id, version, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest version of specified rating algorithm definition.
         * @summary Get Rating Algorithm (latest version)
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestRatingAlgorithm(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<RatingAlgorithm> {
            return EndPointsApiFp(configuration).getLatestRatingAlgorithm(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return EndPointsApiFp(configuration).getMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns existing calculated rating.
         * @summary Retrieve Rating
         * @param {string} id Unique id of the rating resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRating(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<Rating> {
            return EndPointsApiFp(configuration).getRating(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified rating algorithm configuration.
         * @summary Get Rating Algorithm
         * @param {string} id Unique id of the rating algorithm resource.
         * @param {string} version Version of the rating algorithm resource.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<RatingAlgorithm> {
            return EndPointsApiFp(configuration).getRatingAlgorithm(id, version, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated data set rating algorithm resources with optional filter by datasheet property.
         * @summary List Rating Algorithms
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingAlgorithms(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, options?: any): AxiosPromise<RatingAlgorithmPagedModel> {
            return EndPointsApiFp(configuration).getRatingAlgorithms(xINSHURTenant, size, page, datasheetPropertyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndPointsApi - object-oriented interface
 * @export
 * @class EndPointsApi
 * @extends {BaseAPI}
 */
export class EndPointsApi extends BaseAPI {
    /**
     * Generates a rating for a specified package and datasheet.
     * @summary Rate Package
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {RatingRequest} [ratingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createRating(xINSHURTenant?: Tenant, ratingRequest?: RatingRequest, options?: any) {
        return EndPointsApiFp(this.configuration).createRating(xINSHURTenant, ratingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new rating algorithm resource.
     * @summary Create Rating Algorithm
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createRatingAlgorithm(xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any) {
        return EndPointsApiFp(this.configuration).createRatingAlgorithm(xINSHURTenant, ratingAlgorithmBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version of a rating algorithm resource.  The version is automatically calculated from the latest version. TBC how to control a major or minor bump. 
     * @summary Create Rating Algorithm Version
     * @param {string} id Unique id of the rating algorithm resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {RatingAlgorithmBody} [ratingAlgorithmBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createRatingAlgorithmVersion(id: string, xINSHURTenant?: Tenant, ratingAlgorithmBody?: RatingAlgorithmBody, options?: any) {
        return EndPointsApiFp(this.configuration).createRatingAlgorithmVersion(id, xINSHURTenant, ratingAlgorithmBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified rating algorithm configuration.  NOTE: will only allow the delete if the algorithm is not linked to any product. 
     * @summary Delete Rating Algorithm
     * @param {string} id Unique id of the rating algorithm resource.
     * @param {string} version Version of the rating algorithm resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public deleteRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).deleteRatingAlgorithm(id, version, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest version of specified rating algorithm definition.
     * @summary Get Rating Algorithm (latest version)
     * @param {string} id Unique id of the rating algorithm resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getLatestRatingAlgorithm(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getLatestRatingAlgorithm(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
     * @summary Service Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getMetadata(options?: any) {
        return EndPointsApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns existing calculated rating.
     * @summary Retrieve Rating
     * @param {string} id Unique id of the rating resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getRating(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getRating(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified rating algorithm configuration.
     * @summary Get Rating Algorithm
     * @param {string} id Unique id of the rating algorithm resource.
     * @param {string} version Version of the rating algorithm resource.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getRatingAlgorithm(id: string, version: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getRatingAlgorithm(id, version, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated data set rating algorithm resources with optional filter by datasheet property.
     * @summary List Rating Algorithms
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {string} [datasheetPropertyId] Unique id of the datasheet property resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getRatingAlgorithms(xINSHURTenant?: Tenant, size?: number, page?: number, datasheetPropertyId?: string, options?: any) {
        return EndPointsApiFp(this.configuration).getRatingAlgorithms(xINSHURTenant, size, page, datasheetPropertyId, options).then((request) => request(this.axios, this.basePath));
    }

}


