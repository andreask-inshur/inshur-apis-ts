// tslint:disable
/**
 * billing-v1
 * Billing API Service  Manages payments and integration with payment provider Stripe. 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * JSON API message.
 * @export
 * @interface ApiMessage
 */
export interface ApiMessage {
    /**
     * HTTP status code.
     * @type {number}
     * @memberof ApiMessage
     */
    status?: number;
    /**
     * HTTP status text.
     * @type {string}
     * @memberof ApiMessage
     */
    error?: string;
    /**
     * Custom message.
     * @type {string}
     * @memberof ApiMessage
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface CreatedTrait
 */
export interface CreatedTrait {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof CreatedTrait
     */
    createdBy: string;
}
/**
 * Supported currency. From ISO-4217 world currency codes.
 * @export
 * @enum {string}
 */
export enum Currency {
    GBP = 'GBP',
    USD = 'USD',
    EUR = 'EUR'
}

/**
 * Hypermedia link
 * @export
 * @interface HalLink
 */
export interface HalLink {
    /**
     * Hypertext reference
     * @type {string}
     * @memberof HalLink
     */
    href: string;
}
/**
 * 
 * @export
 * @interface HalPageLinks
 */
export interface HalPageLinks {
    /**
     * Link to first page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    first?: HalLink;
    /**
     * Link to next page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    next?: HalLink;
    /**
     * Link to previous page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    prev?: HalLink;
    /**
     * Link to last page in the dataset
     * @type {HalLink}
     * @memberof HalPageLinks
     */
    last?: HalLink;
}
/**
 * HAL/Hypermedia page relations
 * @export
 * @interface HalPageTrait
 */
export interface HalPageTrait {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof HalPageTrait
     */
    _links?: HalPageLinks;
    /**
     * Page metadata.
     * @type {object}
     * @memberof HalPageTrait
     */
    page?: object;
}
/**
 * HAL/Hypermedia resource charactaristics.
 * @export
 * @interface HalResourceTrait
 */
export interface HalResourceTrait {
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof HalResourceTrait
     */
    _embedded?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface HalStripePaymentEventList
 */
export interface HalStripePaymentEventList {
    /**
     * 
     * @type {HalStripePaymentEventListEmbedded}
     * @memberof HalStripePaymentEventList
     */
    _embedded?: HalStripePaymentEventListEmbedded;
}
/**
 * 
 * @export
 * @interface HalStripePaymentEventListEmbedded
 */
export interface HalStripePaymentEventListEmbedded {
    /**
     * 
     * @type {Array<StripePaymentEvent>}
     * @memberof HalStripePaymentEventListEmbedded
     */
    paymentEvents: Array<StripePaymentEvent>;
}
/**
 * HAL/Hypermedia Page
 * @export
 * @interface PagedModel
 */
export interface PagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof PagedModel
     */
    _links: HalPageLinks;
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof PagedModel
     */
    _embedded?: { [key: string]: object; };
    /**
     * Page metadata.
     * @type {object}
     * @memberof PagedModel
     */
    page?: object;
}
/**
 * Payment status for a
 * @export
 * @interface PaymentStatus
 */
export interface PaymentStatus {
    /**
     * 
     * @type {QuoteKey}
     * @memberof PaymentStatus
     */
    quote: QuoteKey;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof PaymentStatus
     */
    packageId: string;
    /**
     * Payment status. OK when valueReceived >= valueRequired; INSUFFICIENT when valueReceived < valueRequired.
     * @type {string}
     * @memberof PaymentStatus
     */
    status: PaymentStatusStatusEnum;
    /**
     * Zero-decimal money value. Lowest currency unit to avoid decimal point coversion complication. Eg. $100.57 = 10057.
     * @type {number}
     * @memberof PaymentStatus
     */
    valueRequired: number;
    /**
     * Zero-decimal money value. Lowest currency unit to avoid decimal point coversion complication. Eg. $100.57 = 10057.
     * @type {number}
     * @memberof PaymentStatus
     */
    valueReceived: number;
    /**
     * The date time that sufficient payment was recieved. Null if sufficient payment has not yet been received.
     * @type {string}
     * @memberof PaymentStatus
     */
    sufficientOn: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentStatusStatusEnum {
    OK = 'OK',
    INSUFFICIENT = 'INSUFFICIENT'
}

/**
 * Reference to a quote resource
 * @export
 * @interface QuoteKey
 */
export interface QuoteKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof QuoteKey
     */
    quoteId: string;
}
/**
 * Resource with HAL/Hypermedia support
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof Resource
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof Resource
     */
    _embedded?: { [key: string]: object; };
}
/**
 * App payment result details.
 * @export
 * @interface StripeAppPaymentEventBody
 */
export interface StripeAppPaymentEventBody {
    /**
     * 
     * @type {QuoteKey}
     * @memberof StripeAppPaymentEventBody
     */
    quote: QuoteKey;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripeAppPaymentEventBody
     */
    packageId: string;
    /**
     * Stripe object relating to the payment event
     * @type {{ [key: string]: object; }}
     * @memberof StripeAppPaymentEventBody
     */
    data: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface StripePaymentEvent
 */
export interface StripePaymentEvent {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    paymentEventId: string;
    /**
     * Type of payment event that this record refers to.  APP_PAYMENT_INTENT - Triggered by the customer web app to initiate the payment process. Billing API requests an intent token from Stripe API which is passed back to the customer web app to use for payment.  APP_PAYMENT_RESULT - Result of the payment from the customer web Stripe client. Customer web app posts this result to the Billing API after payment completes.  STRIPE_PAYMENT_RESULT - Confirmation of a payment from Stripe webhook. Should match one-to-one with an APP_PAYMENT_RESULT record.  API_REFUND_RESULT - Result of a refund triggered from the Billing API.  STRIPE_REFUND_UPDATED - Notification from Stripe webhook regarding a refund that has failed to complete. Should match to an API_REFUND_RESULT. 
     * @type {string}
     * @memberof StripePaymentEvent
     */
    eventType: StripePaymentEventEventTypeEnum;
    /**
     * 
     * @type {QuoteKey}
     * @memberof StripePaymentEvent
     */
    quote: QuoteKey;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    packageId: string;
    /**
     * Unique reference to the user associated with this event.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    userId: string;
    /**
     * UTC date time stamp that the Stripe event occured. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    eventDateTime: string;
    /**
     * Stripes unique identitfier for all events related to a particular payment instruction. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    paymentIntentId: string;
    /**
     * Amount associated with this payment event. This is a zero-decimal money value. This is automatically extracted from Stripes event data object by the service.
     * @type {number}
     * @memberof StripePaymentEvent
     */
    amount: number;
    /**
     * Currency associated with this payment event. This is automatically extracted from Stripes event data object by the service.
     * @type {Currency}
     * @memberof StripePaymentEvent
     */
    currency: Currency;
    /**
     * Indicates the status (failed or succeeded) of the event. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    status: string;
    /**
     * Stripe object relating to the payment event
     * @type {object}
     * @memberof StripePaymentEvent
     */
    data: object;
    /**
     * The UTC date-time stamp that the resource was created. Automatically set by the system.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    createdOn: string;
    /**
     * Reference to the user or service that created the resource. Automatically set by the system.
     * @type {string}
     * @memberof StripePaymentEvent
     */
    createdBy: string;
    /**
     * Hypermedia links
     * @type {{ [key: string]: object; }}
     * @memberof StripePaymentEvent
     */
    _links: { [key: string]: object; };
    /**
     * Hypermedia embedded resources
     * @type {{ [key: string]: object; }}
     * @memberof StripePaymentEvent
     */
    _embedded?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum StripePaymentEventEventTypeEnum {
    APPPAYMENTINTENT = 'APP_PAYMENT_INTENT',
    APPPAYMENTRESULT = 'APP_PAYMENT_RESULT',
    STRIPEPAYMENTRESULT = 'STRIPE_PAYMENT_RESULT',
    APIREFUNDRESULT = 'API_REFUND_RESULT',
    STRIPEREFUNDUPDATED = 'STRIPE_REFUND_UPDATED'
}

/**
 * Payment event record
 * @export
 * @interface StripePaymentEventBody
 */
export interface StripePaymentEventBody {
    /**
     * Type of payment event that this record refers to.  APP_PAYMENT_INTENT - Triggered by the customer web app to initiate the payment process. Billing API requests an intent token from Stripe API which is passed back to the customer web app to use for payment.  APP_PAYMENT_RESULT - Result of the payment from the customer web Stripe client. Customer web app posts this result to the Billing API after payment completes.  STRIPE_PAYMENT_RESULT - Confirmation of a payment from Stripe webhook. Should match one-to-one with an APP_PAYMENT_RESULT record.  API_REFUND_RESULT - Result of a refund triggered from the Billing API.  STRIPE_REFUND_UPDATED - Notification from Stripe webhook regarding a refund that has failed to complete. Should match to an API_REFUND_RESULT. 
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    eventType: StripePaymentEventBodyEventTypeEnum;
    /**
     * 
     * @type {QuoteKey}
     * @memberof StripePaymentEventBody
     */
    quote: QuoteKey;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    packageId: string;
    /**
     * Unique reference to the user associated with this event.
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    userId: string;
    /**
     * UTC date time stamp that the Stripe event occured. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    eventDateTime: string;
    /**
     * Stripes unique identitfier for all events related to a particular payment instruction. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    paymentIntentId: string;
    /**
     * Amount associated with this payment event. This is a zero-decimal money value. This is automatically extracted from Stripes event data object by the service.
     * @type {number}
     * @memberof StripePaymentEventBody
     */
    amount: number;
    /**
     * Currency associated with this payment event. This is automatically extracted from Stripes event data object by the service.
     * @type {Currency}
     * @memberof StripePaymentEventBody
     */
    currency: Currency;
    /**
     * Indicates the status (failed or succeeded) of the event. This is automatically extracted from Stripes event data object by the service.
     * @type {string}
     * @memberof StripePaymentEventBody
     */
    status: string;
    /**
     * Stripe object relating to the payment event
     * @type {object}
     * @memberof StripePaymentEventBody
     */
    data: object;
}

/**
    * @export
    * @enum {string}
    */
export enum StripePaymentEventBodyEventTypeEnum {
    APPPAYMENTINTENT = 'APP_PAYMENT_INTENT',
    APPPAYMENTRESULT = 'APP_PAYMENT_RESULT',
    STRIPEPAYMENTRESULT = 'STRIPE_PAYMENT_RESULT',
    APIREFUNDRESULT = 'API_REFUND_RESULT',
    STRIPEREFUNDUPDATED = 'STRIPE_REFUND_UPDATED'
}

/**
 * Payment event reference
 * @export
 * @interface StripePaymentEventKey
 */
export interface StripePaymentEventKey {
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripePaymentEventKey
     */
    paymentEventId: string;
}
/**
 * 
 * @export
 * @interface StripePaymentEventPagedModel
 */
export interface StripePaymentEventPagedModel {
    /**
     * 
     * @type {HalPageLinks}
     * @memberof StripePaymentEventPagedModel
     */
    _links: HalPageLinks;
    /**
     * 
     * @type {HalStripePaymentEventListEmbedded}
     * @memberof StripePaymentEventPagedModel
     */
    _embedded?: HalStripePaymentEventListEmbedded;
    /**
     * Page metadata.
     * @type {object}
     * @memberof StripePaymentEventPagedModel
     */
    page?: object;
}
/**
 * Stripe payment intent client_secret token
 * @export
 * @interface StripePaymentIntent
 */
export interface StripePaymentIntent {
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    clientSecret: string;
}
/**
 * Stripe payment intent request.
 * @export
 * @interface StripePaymentIntentRequest
 */
export interface StripePaymentIntentRequest {
    /**
     * 
     * @type {QuoteKey}
     * @memberof StripePaymentIntentRequest
     */
    quote: QuoteKey;
    /**
     * Internal unique identifier.
     * @type {string}
     * @memberof StripePaymentIntentRequest
     */
    packageId: string;
    /**
     * Zero-decimal money value. Lowest currency unit to avoid decimal point coversion complication. Eg. $100.57 = 10057.
     * @type {number}
     * @memberof StripePaymentIntentRequest
     */
    amount: number;
    /**
     * 
     * @type {Currency}
     * @memberof StripePaymentIntentRequest
     */
    currency: Currency;
}
/**
 * Stripe refund reciept
 * @export
 * @interface StripeRefund
 */
export interface StripeRefund {
    /**
     * Reference to the new payment event relating to the refund
     * @type {StripePaymentEventKey}
     * @memberof StripeRefund
     */
    paymentEvent: StripePaymentEventKey;
    /**
     * Stripe object relating to the refund event
     * @type {object}
     * @memberof StripeRefund
     */
    data: object;
}
/**
 * Stripe refund request body
 * @export
 * @interface StripeRefundRequest
 */
export interface StripeRefundRequest {
    /**
     * Reference to the payment event to be refunded
     * @type {StripePaymentEventKey}
     * @memberof StripeRefundRequest
     */
    paymentEvent: StripePaymentEventKey;
    /**
     * Zero-decimal money amount to be refunded. Note that currency is taken to be the same as that of the payment event.
     * @type {number}
     * @memberof StripeRefundRequest
     */
    amount: number;
}
/**
 * Related platform tenant.
 * @export
 * @enum {string}
 */
export enum Tenant {
    INSHUR = 'INSHUR'
}


/**
 * EndPointsApi - axios parameter creator
 * @export
 */
export const EndPointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new payment event record resource from a client app.
         * @summary Record App Payment Event
         * @param {StripeAppPaymentEventBody} stripeAppPaymentEventBody 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentEventFromApp: async (stripeAppPaymentEventBody: StripeAppPaymentEventBody, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeAppPaymentEventBody' is not null or undefined
            if (stripeAppPaymentEventBody === null || stripeAppPaymentEventBody === undefined) {
                throw new RequiredError('stripeAppPaymentEventBody','Required parameter stripeAppPaymentEventBody was null or undefined when calling createPaymentEventFromApp.');
            }
            const localVarPath = `/stripe/payment-event/app`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof stripeAppPaymentEventBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(stripeAppPaymentEventBody !== undefined ? stripeAppPaymentEventBody : {}) : (stripeAppPaymentEventBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new stripe payment event record from Stripe webhook notification.
         * @summary Record Stripe Payment Event
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripePaymentEventFromWebhook: async (requestBody?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/payment-event/webhook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication stripeSignatureAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Stripe-Signature")
                    : await configuration.apiKey;
                localVarHeaderParameter["Stripe-Signature"] = localVarApiKeyValue;
            }

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified payment event record.
         * @summary Get Stripe Payment Event
         * @param {string} id Unique id of the payment event record.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentEvent: async (id: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPaymentEvent.');
            }
            const localVarPath = `/stripe/payment-event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated dataset of stripe payment events with optional filter by user or quote.   Requires role(s): ```admin``` 
         * @summary List Stripe Payment Events
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [userId] User reference.
         * @param {string} [quoteId] Quote reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentEvents: async (xINSHURTenant?: Tenant, size?: number, page?: number, userId?: string, quoteId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/payment-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (quoteId !== undefined) {
                localVarQueryParameter['quoteId'] = quoteId;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the payment status for a specified quote and package combination.
         * @summary Get Payment Status
         * @param {string} quoteId Unique id of the quote.
         * @param {string} packageId Id of the package.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentStatus: async (quoteId: string, packageId: string, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteId' is not null or undefined
            if (quoteId === null || quoteId === undefined) {
                throw new RequiredError('quoteId','Required parameter quoteId was null or undefined when calling getPaymentStatus.');
            }
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling getPaymentStatus.');
            }
            const localVarPath = `/payment-status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (quoteId !== undefined) {
                localVarQueryParameter['quoteId'] = quoteId;
            }

            if (packageId !== undefined) {
                localVarQueryParameter['packageId'] = packageId;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a payment intent event with Stripe and returns the secret token.
         * @summary Create Stripe Payment Intent
         * @param {StripePaymentIntentRequest} stripePaymentIntentRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePaymentIntent: async (stripePaymentIntentRequest: StripePaymentIntentRequest, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripePaymentIntentRequest' is not null or undefined
            if (stripePaymentIntentRequest === null || stripePaymentIntentRequest === undefined) {
                throw new RequiredError('stripePaymentIntentRequest','Required parameter stripePaymentIntentRequest was null or undefined when calling getStripePaymentIntent.');
            }
            const localVarPath = `/stripe/payment-intent`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof stripePaymentIntentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(stripePaymentIntentRequest !== undefined ? stripePaymentIntentRequest : {}) : (stripePaymentIntentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a Stripe refund.
         * @summary Create Stripe Refund
         * @param {StripeRefundRequest} stripeRefundRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeRefund: async (stripeRefundRequest: StripeRefundRequest, xINSHURTenant?: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeRefundRequest' is not null or undefined
            if (stripeRefundRequest === null || stripeRefundRequest === undefined) {
                throw new RequiredError('stripeRefundRequest','Required parameter stripeRefundRequest was null or undefined when calling getStripeRefund.');
            }
            const localVarPath = `/stripe/refund`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xINSHURTenant !== undefined && xINSHURTenant !== null) {
                localVarHeaderParameter['X-INSHUR-Tenant'] = String(JSON.stringify(xINSHURTenant));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof stripeRefundRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(stripeRefundRequest !== undefined ? stripeRefundRequest : {}) : (stripeRefundRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndPointsApi - functional programming interface
 * @export
 */
export const EndPointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new payment event record resource from a client app.
         * @summary Record App Payment Event
         * @param {StripeAppPaymentEventBody} stripeAppPaymentEventBody 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentEventFromApp(stripeAppPaymentEventBody: StripeAppPaymentEventBody, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentEvent>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createPaymentEventFromApp(stripeAppPaymentEventBody, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new stripe payment event record from Stripe webhook notification.
         * @summary Record Stripe Payment Event
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStripePaymentEventFromWebhook(requestBody?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentEvent>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).createStripePaymentEventFromWebhook(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified payment event record.
         * @summary Get Stripe Payment Event
         * @param {string} id Unique id of the payment event record.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentEvent(id: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentEvent>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getPaymentEvent(id, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paginated dataset of stripe payment events with optional filter by user or quote.   Requires role(s): ```admin``` 
         * @summary List Stripe Payment Events
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [userId] User reference.
         * @param {string} [quoteId] Quote reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentEvents(xINSHURTenant?: Tenant, size?: number, page?: number, userId?: string, quoteId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentEventPagedModel>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getPaymentEvents(xINSHURTenant, size, page, userId, quoteId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the payment status for a specified quote and package combination.
         * @summary Get Payment Status
         * @param {string} quoteId Unique id of the quote.
         * @param {string} packageId Id of the package.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentStatus(quoteId: string, packageId: string, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatus>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getPaymentStatus(quoteId, packageId, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a payment intent event with Stripe and returns the secret token.
         * @summary Create Stripe Payment Intent
         * @param {StripePaymentIntentRequest} stripePaymentIntentRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripePaymentIntent(stripePaymentIntentRequest: StripePaymentIntentRequest, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntent>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getStripePaymentIntent(stripePaymentIntentRequest, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Process a Stripe refund.
         * @summary Create Stripe Refund
         * @param {StripeRefundRequest} stripeRefundRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeRefund(stripeRefundRequest: StripeRefundRequest, xINSHURTenant?: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeRefund>> {
            const localVarAxiosArgs = await EndPointsApiAxiosParamCreator(configuration).getStripeRefund(stripeRefundRequest, xINSHURTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EndPointsApi - factory interface
 * @export
 */
export const EndPointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new payment event record resource from a client app.
         * @summary Record App Payment Event
         * @param {StripeAppPaymentEventBody} stripeAppPaymentEventBody 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentEventFromApp(stripeAppPaymentEventBody: StripeAppPaymentEventBody, xINSHURTenant?: Tenant, options?: any): AxiosPromise<StripePaymentEvent> {
            return EndPointsApiFp(configuration).createPaymentEventFromApp(stripeAppPaymentEventBody, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new stripe payment event record from Stripe webhook notification.
         * @summary Record Stripe Payment Event
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStripePaymentEventFromWebhook(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<StripePaymentEvent> {
            return EndPointsApiFp(configuration).createStripePaymentEventFromWebhook(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
         * @summary Service Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return EndPointsApiFp(configuration).getMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified payment event record.
         * @summary Get Stripe Payment Event
         * @param {string} id Unique id of the payment event record.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentEvent(id: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<StripePaymentEvent> {
            return EndPointsApiFp(configuration).getPaymentEvent(id, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated dataset of stripe payment events with optional filter by user or quote.   Requires role(s): ```admin``` 
         * @summary List Stripe Payment Events
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {number} [size] Page size.
         * @param {number} [page] Page number. Zero-based page index. Default 0.
         * @param {string} [userId] User reference.
         * @param {string} [quoteId] Quote reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentEvents(xINSHURTenant?: Tenant, size?: number, page?: number, userId?: string, quoteId?: string, options?: any): AxiosPromise<StripePaymentEventPagedModel> {
            return EndPointsApiFp(configuration).getPaymentEvents(xINSHURTenant, size, page, userId, quoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the payment status for a specified quote and package combination.
         * @summary Get Payment Status
         * @param {string} quoteId Unique id of the quote.
         * @param {string} packageId Id of the package.
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentStatus(quoteId: string, packageId: string, xINSHURTenant?: Tenant, options?: any): AxiosPromise<PaymentStatus> {
            return EndPointsApiFp(configuration).getPaymentStatus(quoteId, packageId, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a payment intent event with Stripe and returns the secret token.
         * @summary Create Stripe Payment Intent
         * @param {StripePaymentIntentRequest} stripePaymentIntentRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePaymentIntent(stripePaymentIntentRequest: StripePaymentIntentRequest, xINSHURTenant?: Tenant, options?: any): AxiosPromise<StripePaymentIntent> {
            return EndPointsApiFp(configuration).getStripePaymentIntent(stripePaymentIntentRequest, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a Stripe refund.
         * @summary Create Stripe Refund
         * @param {StripeRefundRequest} stripeRefundRequest 
         * @param {Tenant} [xINSHURTenant] Platform tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeRefund(stripeRefundRequest: StripeRefundRequest, xINSHURTenant?: Tenant, options?: any): AxiosPromise<StripeRefund> {
            return EndPointsApiFp(configuration).getStripeRefund(stripeRefundRequest, xINSHURTenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndPointsApi - object-oriented interface
 * @export
 * @class EndPointsApi
 * @extends {BaseAPI}
 */
export class EndPointsApi extends BaseAPI {
    /**
     * Creates a new payment event record resource from a client app.
     * @summary Record App Payment Event
     * @param {StripeAppPaymentEventBody} stripeAppPaymentEventBody 
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createPaymentEventFromApp(stripeAppPaymentEventBody: StripeAppPaymentEventBody, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).createPaymentEventFromApp(stripeAppPaymentEventBody, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new stripe payment event record from Stripe webhook notification.
     * @summary Record Stripe Payment Event
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public createStripePaymentEventFromWebhook(requestBody?: { [key: string]: object; }, options?: any) {
        return EndPointsApiFp(this.configuration).createStripePaymentEventFromWebhook(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns internal service deployment metadata.  Requires role(s): ```monitor``` 
     * @summary Service Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getMetadata(options?: any) {
        return EndPointsApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified payment event record.
     * @summary Get Stripe Payment Event
     * @param {string} id Unique id of the payment event record.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getPaymentEvent(id: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getPaymentEvent(id, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated dataset of stripe payment events with optional filter by user or quote.   Requires role(s): ```admin``` 
     * @summary List Stripe Payment Events
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {number} [size] Page size.
     * @param {number} [page] Page number. Zero-based page index. Default 0.
     * @param {string} [userId] User reference.
     * @param {string} [quoteId] Quote reference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getPaymentEvents(xINSHURTenant?: Tenant, size?: number, page?: number, userId?: string, quoteId?: string, options?: any) {
        return EndPointsApiFp(this.configuration).getPaymentEvents(xINSHURTenant, size, page, userId, quoteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the payment status for a specified quote and package combination.
     * @summary Get Payment Status
     * @param {string} quoteId Unique id of the quote.
     * @param {string} packageId Id of the package.
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getPaymentStatus(quoteId: string, packageId: string, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getPaymentStatus(quoteId, packageId, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a payment intent event with Stripe and returns the secret token.
     * @summary Create Stripe Payment Intent
     * @param {StripePaymentIntentRequest} stripePaymentIntentRequest 
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getStripePaymentIntent(stripePaymentIntentRequest: StripePaymentIntentRequest, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getStripePaymentIntent(stripePaymentIntentRequest, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a Stripe refund.
     * @summary Create Stripe Refund
     * @param {StripeRefundRequest} stripeRefundRequest 
     * @param {Tenant} [xINSHURTenant] Platform tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndPointsApi
     */
    public getStripeRefund(stripeRefundRequest: StripeRefundRequest, xINSHURTenant?: Tenant, options?: any) {
        return EndPointsApiFp(this.configuration).getStripeRefund(stripeRefundRequest, xINSHURTenant, options).then((request) => request(this.axios, this.basePath));
    }

}


